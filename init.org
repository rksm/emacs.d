* requirements / packages

** load path, etc.
#+BEGIN_SRC emacs-lisp
  ;; emacs-major-version
  ;; emacs-minor-version
  ;; (emacs-version)
  ;(add-to-list 'load-path (expand-file-name "~/.emacs.d"))
#+END_SRC

** elpa
*package.el* proved to be sufficient for getting recent packages/projects from
ELPA/marmalade repos.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
  (add-to-list 'package-archives '("tromey" . "http://tromey.com/elpa/") t)
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (package-initialize)

  ;; (makunbound 'my-packages)
  (defvar my-packages
    '(dash dash-functional s
           diminish
           iy-go-to-char
           ace-jump-mode
           multiple-cursors
           expand-region
           move-text
           auto-complete
           helm ac-helm
           wgrep
           magit
           projectile
           helm-projectile
           perspective
           ;; programming
           slime
           ;; weby stuff
           markdown-mode
           ;; js
           js3-mode
           ;; lispy things
           elisp-slime-nav
           paredit
           clojure-mode clojure-test-mode cider troncle clojure-cheatsheet
           ;; erc
           ;; znc ;; bouncer
           ;; haskellme
           haskell-mode
           ghci-completion
           flycheck-haskell
           ;; flymake-hlint
           ;; flymake-haskell-multi
           noctilux-theme
           ))
  
  (dolist (p my-packages)
    (when (not (package-installed-p p))
      (package-install p)))
#+END_SRC
** site-lisp
#+BEGIN_SRC elisp
  (add-to-list 'load-path (concat (expand-file-name "~/.emacs.d/site-lisp/") "fringemark"))
  (add-to-list 'load-path (concat (expand-file-name "~/.emacs.d/site-lisp/") "swank-js"))
#+END_SRC
* generic settings
** system-related
#+BEGIN_SRC emacs-lisp
(setq *spell-check-support-enabled* t)
(setq *is-a-mac* (eq system-type 'darwin))
(setq *is-carbon-emacs* (and *is-a-mac* (eq window-system 'mac)))
(setq *is-cocoa-emacs* (and *is-a-mac* (eq window-system 'ns)))
#+END_SRC

** emacs interaction
#+BEGIN_SRC emacs-lisp
   (setq-default blink-cursor-delay 0
                 mouse-highlight nil
                 bookmark-default-file "~/.emacs.d/.bookmarks.el"
                 buffers-menu-max-size 30
                 case-fold-search t
                 compilation-scroll-output t
                 ediff-split-window-function 'split-window-horizontally
                 ediff-window-setup-function 'ediff-setup-windows-plain
                 grep-highlight-matches t
                 grep-scroll-output nil
                 indent-tabs-mode nil
                 tab-width 4
                 ;; line-spacing 0.2
                 set-mark-command-repeat-pop t
                 show-trailing-whitespace t
                 ;; tooltip-delay 1.5
                 truncate-lines nil
                 truncate-partial-width-windows nil
                 visible-bell t
                 fill-column 80
                 ;; backups
                 make-backup-files t
                 backup-directory-alist '(("." . "~/.emacs.d/backups"))
                 kept-new-versions 6
                 kept-old-versions 2
                 version-control t
                 delete-old-versions t
                 ;; autosave
                 auto-save-file-name-transforms
                 `(("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" ,temporary-file-directory t)
                   (".*" "~/.emacs.d/backups" t))
                 ;; lock files
                 create-lockfiles nil)
  
  (fset 'yes-or-no-p 'y-or-n-p)
  (column-number-mode 1)
  (blink-cursor-mode 0)
  (setq initial-scratch-message "")
  (setq inhibit-startup-message t)
  (scroll-bar-mode 0)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  
  (setq show-paren-delay 0
        show-paren-style 'parenthesis)
  (show-paren-mode 1)
  (electric-pair-mode 1)
  (electric-indent-mode -1)
   (transient-mark-mode t)
   (delete-selection-mode 1)
  
   ;; remember cursor pos
   (setq save-place t)
   (require 'saveplace)
   (setq save-place-file "~/.emacs.d/saved-places")
  
  ;;; enable disabled commands
  (put 'narrow-to-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  
#+END_SRC

** snippets
#+BEGIN_SRC elisp
  (require 'yasnippet)
  (yas-global-mode)
  (setq yas-prompt-functions '(yas-completing-prompt yas-ido-prompt yas-no-prompt))
  (setq yas-indent-line 'fixed)
  (global-set-key (kbd "s-C") 'yas-insert-snippet)
#+END_SRC
** hippie
#+BEGIN_SRC elisp
  (defvar he-search-loc-backward (make-marker))
  (defvar he-search-loc-forward (make-marker))
  
  (defun try-expand-dabbrev-closest-first (old)
    "Try to expand word \"dynamically\", searching the current buffer.
  The argument OLD has to be nil the first call of this function, and t
  for subsequent calls (for further possible expansions of the same
  string).  It returns t if a new expansion is found, nil otherwise."
    (let (expansion)
      (unless old
        (he-init-string (he-dabbrev-beg) (point))
        (set-marker he-search-loc-backward he-string-beg)
        (set-marker he-search-loc-forward he-string-end))
  
      (if (not (equal he-search-string ""))
          (save-excursion
            (save-restriction
              (if hippie-expand-no-restriction
                  (widen))
  
              (let (forward-point
                    backward-point
                    forward-distance
                    backward-distance
                    forward-expansion
                    backward-expansion
                    chosen)
  
                ;; search backward
                (goto-char he-search-loc-backward)
                (setq expansion (he-dabbrev-search he-search-string t))
  
                (when expansion
                  (setq backward-expansion expansion)
                  (setq backward-point (point))
                  (setq backward-distance (- he-string-beg backward-point)))
  
                ;; search forward
                (goto-char he-search-loc-forward)
                (setq expansion (he-dabbrev-search he-search-string nil))
  
                (when expansion
                  (setq forward-expansion expansion)
                  (setq forward-point (point))
                  (setq forward-distance (- forward-point he-string-beg)))
  
                ;; choose depending on distance
                (setq chosen (cond
                              ((and forward-point backward-point)
                               (if (< forward-distance backward-distance) :forward :backward))
  
                              (forward-point :forward)
                              (backward-point :backward)))
  
                (when (equal chosen :forward)
                  (setq expansion forward-expansion)
                  (set-marker he-search-loc-forward forward-point))
  
                (when (equal chosen :backward)
                  (setq expansion backward-expansion)
                  (set-marker he-search-loc-backward backward-point))
  
                ))))
  
      (if (not expansion)
          (progn
            (if old (he-reset-string))
            nil)
        (progn
          (he-substitute-string expansion t)
          t))))
  
  (defun try-expand-line-closest-first (old)
    "Try to complete the current line to an entire line in the buffer.
  The argument OLD has to be nil the first call of this function, and t
  for subsequent calls (for further possible completions of the same
  string).  It returns t if a new completion is found, nil otherwise."
    (let ((expansion ())
          (strip-prompt (and (get-buffer-process (current-buffer))
                             comint-use-prompt-regexp
                             comint-prompt-regexp)))
      (unless old
        (he-init-string (he-line-beg strip-prompt) (point))
        (set-marker he-search-loc-backward he-string-beg)
        (set-marker he-search-loc-forward he-string-end))
  
      (if (not (equal he-search-string ""))
          (save-excursion
            (save-restriction
              (if hippie-expand-no-restriction
                  (widen))
  
              (let (forward-point
                    backward-point
                    forward-distance
                    backward-distance
                    forward-expansion
                    backward-expansion
                    chosen)
  
                ;; search backward
                (goto-char he-search-loc-backward)
                (setq expansion (he-line-search he-search-string
                                                strip-prompt t))
  
                (when expansion
                  (setq backward-expansion expansion)
                  (setq backward-point (point))
                  (setq backward-distance (- he-string-beg backward-point)))
  
                ;; search forward
                (goto-char he-search-loc-forward)
                (setq expansion (he-line-search he-search-string
                                                strip-prompt nil))
  
                (when expansion
                  (setq forward-expansion expansion)
                  (setq forward-point (point))
                  (setq forward-distance (- forward-point he-string-beg)))
  
                ;; choose depending on distance
                (setq chosen (cond
                              ((and forward-point backward-point)
                               (if (< forward-distance backward-distance) :forward :backward))
  
                              (forward-point :forward)
                              (backward-point :backward)))
  
                (when (equal chosen :forward)
                  (setq expansion forward-expansion)
                  (set-marker he-search-loc-forward forward-point))
  
                (when (equal chosen :backward)
                  (setq expansion backward-expansion)
                  (set-marker he-search-loc-backward backward-point))
  
                ))))
  
      (if (not expansion)
          (progn
            (if old (he-reset-string))
            ())
        (progn
          (he-substitute-string expansion t)
          t))))
  
  ;; Hippie expand: sometimes too hip
  (setq hippie-expand-try-functions-list '(try-expand-dabbrev-closest-first
                                           try-complete-file-name
                                           try-expand-dabbrev-all-buffers
                                           try-expand-dabbrev-from-kill
                                           try-expand-all-abbrevs
                                           try-complete-lisp-symbol-partially
                                           try-complete-lisp-symbol))
  
  ;; Create own function to expand lines (C-S-.)
  (defun hippie-expand-lines ()
    (interactive)
    (let ((hippie-expand-try-functions-list '(try-expand-line-closest-first
                                              try-expand-line-all-buffers)))
      (end-of-line)
      (hippie-expand nil)))
  
  ;; Don't case-fold when expanding with hippe
  (defun hippie-expand-no-case-fold ()
    (interactive)
    (let ((case-fold-search nil))
      (hippie-expand nil)))
#+END_SRC

* useful functions
** emacs API
#+BEGIN_SRC elisp
  (require 'dash)
  (require 's)
 #+END_SRC

** navigation
#+BEGIN_SRC elisp
  (defun rk/forward-to-match (re)
    ""
    (re-search-forward re (point-max) t)
    (goto-char (match-beginning 0)))
#+END_SRC

** strings and list processing
#+BEGIN_SRC emacs-lisp
  (defun rk/filter (condp lst)
    (delq nil (mapcar (lambda (x) (and (funcall condp x) x)) lst)))
  
  ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  (defun my-string-starts-with (start-string string)
    (when (<= (length start-string) (length string))
      (string-equal
       start-string
       (substring string 0 (length start-string)))))
  
  (defun my-include-list (list element)
    (let ((item (car list)))
      (cond
       ((equal nil item) nil)
       ((equal element item) t)
       (t (my-include-list (cdr list) element)))))
  
  (defun rk/string-join (list &optional separator item-converter)
    (mapconcat (or item-converter 'identity) list (or separator "\n")))
  
  (defun rk/string-match (string regexp index-or-list)
    "match string with regexp and return those matches defined by `index-or-list'"
    (save-match-data
      (let ((success (string-match regexp string)))
       (when success
         (if (numberp index-or-list)
             (match-string-no-properties index-or-list string)
           (mapcar (lambda (n) (match-string-no-properties n string)) index-or-list))))))
  
  (defun rk/string-trim (str)
    "Chomp leading and tailing whitespace from STR."
    (while (string-match "\\`\n+\\|^\\s-+\\|\\s-+$\\|\n+\\'"
                         str)
      (setq str (replace-match "" t t str)))
    str)
  
  (defun rk/string-replace-all (string match-string replacement)
    (let ((case-fold-search nil))
      (while (string-match match-string string)
        (setq string (replace-match replacement t t string))))
    string)
  
  (defun rk/current-line-string ()
    "string with no props"
    (buffer-substring-no-properties (point-at-bol) (point-at-eol)))
  
  (defun rk/current-region-or-line-string ()
    "string comes with no props"
    (rk/with-active-region-or-line start end
      (buffer-substring-no-properties start end)))
  
  (defun rk/current-line-indent ()
    "returns the indent of the line at point as a string"
    (let ((line (rk/current-line-string)))
      (or (rk/string-match line "^[\s]+" 0) "")))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; line iterating/replacement
  (defun rk/do-for-each-line-in-region (func &optional no-insert)
    "applies func to each line in region"
    (let* ((start (if (region-active-p) (mark) (buffer-end -1)))
           (end (if (region-active-p) (point) (buffer-end 1)))
           (lines (split-string (buffer-substring-no-properties start end) "[\n]+"))
           (count -1)
           (with-count (= 2 (length (help-function-arglist func))))
           (replacement-for-lines (mapcar
                                   `(lambda (line)
                                      ,(append '(funcall
                                                 func
                                                 line)
                                               (when with-count '((setq count (1+ count))))))
                                   lines)))
      (progn
        (unless no-insert
          (kill-region start end)
          (insert (s-join "\n" replacement-for-lines)))
        replacement-for-lines)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (defun rk/stringify-line (line &optional is-first)
    (concat
     (if is-first "\"" "+ \"")
     (replace-regexp-in-string "\"" "\\\"" line t t)
     "\\n\""))
  
  (defun rk/unstringify-line (line)
    (let ((replacements '(;; ("\\\"" . "\"")
                          ("^\\\(\\s-*\\\)\"\\|\"\\s-*$" . "\\1")    ; remove <"> at line starts
                          ("\\(\\\\n\\)?\"\\s-+\\+" . "")  ; remove <" +> and <\n" +>
                          ("\\\\\"" . "\"") ; <\"> --> <">
                          )))
      (reduce (lambda (string pair) (replace-regexp-in-string (car pair) (cdr pair) string)) replacements :initial-value line)))
  
  (defun rk/stringify-region (start end)
    (interactive "r")
    (if (and start end)
        (rk/do-for-each-line-in-region (lambda (line i)
                                         (rk/stringify-line line (= i 0))))))
  
  (defun rk/unstringify-region (start end)
    (interactive "r")
    (if (and start end)
        (rk/do-for-each-line-in-region 'rk/unstringify-line)))
  
  (defun rk/copy-stringified ()
    "pipe region or buffer through `rk/stringify-region' and put
  the result into the clipboard"
    (interactive)
    (rk/with-string-from-active-region-or-whole-buffer string
      (with-temp-buffer
        (insert string)
        (rk/stringify-region (point-min) (point-max))
        (kill-region (point-min) (point-max)))))
  
  
#+END_SRC
** buffer related
#+BEGIN_SRC elisp
    (require 'fringemark)
    (defun rk/fringe-shrink ()
      "for focusing on one buffer"
      (interactive)
      (let* ((target-frame-width 950)
            (required-fringe-width (- (frame-pixel-width) target-frame-width)))
        (unless (< (frame-pixel-width) target-frame-width)
          (set-fringe-style (floor required-fringe-width 2)))))
  
    (defun rk/fringe-widen ()
      (interactive)
      (set-fringe-style nil))
  
  ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (defun rk/split-buffer (buffer-or-name &optional separator)
    "split the buffer contents using `separator'"
    (let ((sep (or separator "\n----*\n")))
      (split-string (with-current-buffer buffer-or-name
                      (buffer-substring-no-properties (point-min) (point-max))) sep)))
  
  (defun rk/split-buffer-and-do (buffer-or-name do-func &optional separator)
    (mapc do-func (rk/split-buffer buffer-or-name separator)))
  
  (defun rk/create-file (filename &optional content)
    "create a buffer from `filename' and immediately save it"
    (interactive "F")
    (let ((buf (create-file-buffer filename)))
      (with-current-buffer buf
        (progn
          (setq buffer-file-name filename)
          (if content
              (insert content)
            (set-buffer-modified-p t))
          (save-buffer)))))
  
  (defun rk/split-buffer-and-save-parts (buffer-or-name filename-func &optional separator)
    "split the buffer using separator and save each splits in a buffer/file using `filename-func'.
  `filename-func' expects the splitted content as arg"
    (rk/split-buffer-and-do
     buffer-or-name
     (lambda (content) (rk/create-file (funcall filename-func content) content))
     separator))
  
  ;;; http://www.emacswiki.org/emacs/SwitchingBuffers#toc7
  (defun transpose-buffers (arg)
    "Transpose the buffers shown in two windows."
    (interactive "p")
    (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
      (while (/= arg 0)
        (let ((this-win (window-buffer))
              (next-win (window-buffer (funcall selector))))
          (set-window-buffer (selected-window) next-win)
          (set-window-buffer (funcall selector) this-win)
          (select-window (funcall selector)))
        (setq arg (if (plusp arg) (1- arg) (1+ arg))))))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; http://whattheemacsd.com/key-bindings.el-01.html
  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (linum-mode 1)
          (goto-line (read-number "Goto line: ")))
      (linum-mode -1)))
#+END_SRC
** buffers
#+BEGIN_SRC emacs-lisp
;;; http://stackoverflow.com/questions/3669511/the-function-to-show-current-files-full-path-in-mini-buffer
(defun rk/copy-full-path-to-kill-ring ()
  "copy buffer's full path to kill ring"
  (interactive)
  (when buffer-file-name
    (let ((file-name (file-truename buffer-file-name)))
      (message file-name)
      (kill-new file-name))))

(defun rk/copy-buffer-name-to-kill-ring ()
  "copy buffer's full path to kill ring"
  (interactive)
  (when buffer-file-name
    (let ((name (file-name-nondirectory buffer-file-name)))
      (message name)
      (kill-new name))))
#+END_SRC

** editing commands
*** lines
#+BEGIN_SRC emacs-lisp
  (defun rk/clear-buffer ()
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)))

  (defun rk/open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  (defun rk/open-line-above ()
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))
#+END_SRC

** comments
#+BEGIN_SRC elisp
  ;;; allow-line-as-region-for-function adds an "-or-line" version of
  ;;; the given comment function which (un)comments the current line is
  ;;; the mark is not active.  This code comes from Aquamac's osxkeys.el
  ;;; and is licensed under the GPL

  (defmacro allow-line-as-region-for-function (orig-function)
  `(defun ,(intern (concat (symbol-name orig-function) "-or-line"))
     ()
     ,(format "Like `%s', but acts on the current line if mark is not active."
              orig-function)
     (interactive)
     (if mark-active
         (call-interactively (function ,orig-function))
       (save-excursion
         ;; define a region (temporarily) -- so any C-u prefixes etc. are preserved.
         (beginning-of-line)
         (set-mark (point))
         (end-of-line)
         (call-interactively (function ,orig-function))))))

  (defun rk/define-line-functions ()
    "Add or-line (un)comment function if not already defined"
    (unless (fboundp 'comment-or-uncomment-region-or-line)
      (allow-line-as-region-for-function comment-or-uncomment-region))
    (unless (fboundp 'kill-region-or-line)
      (allow-line-as-region-for-function kill-region)))

  (rk/define-line-functions)

; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  (defun rk/divider (&optional length suppress-newline)
    (interactive "p")
    (message (prin1-to-string length))
    (when (or (not length) (= length 1)) (setq length 58))
    (when (< length 6) (setq length 6))
    (beginning-of-line)
    (let ((div-start-pos (point)))
      ;; (set-mark div-start-pos)
      (delete-horizontal-space)
      (insert "-")
      (comment-or-uncomment-region-or-line)
      (indent-according-to-mode)
      (end-of-line)
      (setq length (- length (- (point) div-start-pos)))
      (insert (apply 'concat (make-list (/ length 2) "=-")))
      (if suppress-newline
          (forward-line)
        (insert "\n"))))

  (defun rk/comment-box (reg-start reg-end)
    "my own comment box, using the divider"
    (interactive "r")
    (let ((start (if (region-active-p) reg-start (line-beginning-position)))
          (end (if (region-active-p) reg-end (line-end-position))))
      (comment-or-uncomment-region-or-line)
      (indent-according-to-mode)
      (setq end (line-end-position))
      (setq max-line-length 0)
      (unless (region-active-p)
        (set-mark start) (goto-char end))
      (rk/do-for-each-line-in-region (lambda (line)
                                       (setq max-line-length
                                             (max max-line-length (length line)))
                                       line) t)
      (setq max-line-length (+ max-line-length (length (rk/current-line-indent))))
      (deactivate-mark)
      (goto-char end)
      (newline)
      (rk/divider (1+ max-line-length) t)
      (goto-char start)
      (forward-line -1)
      (end-of-line)
      (newline)
      (rk/divider (1+ max-line-length) t)))
#+END_SRC
** regions
#+BEGIN_SRC elisp
(defmacro rk/with-active-region-or-whole-buffer (start end &rest body)
  "bind `start' and `end' to region start/end or if no region
active to `point-min' and `point-max'"
  (declare (indent 2) (debug t))
  `(let ((,start (if (region-active-p) (region-beginning) (point-min)))
         (,end (if (region-active-p) (region-end) (point-max))))
     ,@body))

(defmacro rk/with-active-region-or-line (start end &rest body)
  "bind `start' and `end' to region start/end or if no region
active to `point-min' and `point-max'"
  (declare (indent 2) (debug t))
  `(let ((,start (if (region-active-p) (region-beginning) (point-at-bol)))
         (,end (if (region-active-p) (region-end) (point-at-eol))))
     ,@body))

(defmacro rk/with-string-from-active-region-or-whole-buffer (string-name &rest body)
  "bind `start' and `end' to region start/end or if no region
active to `point-min' and `point-max'"
  (declare (indent 1) (debug t))
  (let ((start-name (gensym))
        (end-name (gensym)))
   `(rk/with-active-region-or-whole-buffer ,start-name ,end-name
      (let ((,string-name (buffer-substring-no-properties ,start-name ,end-name)))
        ,@body))))

(defun rk/activate-region (from to)
  "activate region in specified range and evaluate body"
  (let (deactivate-mark)
    (push-mark from t t)
    (goto-char to)))

; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

(defun rk/set-mark-on-shift-press ()
  (when (and this-command-keys-shift-translated
             (not (region-active-p)))
    (set-mark (point))))

#+END_SRC
** modes
#+BEGIN_SRC elisp
(defmacro rk/link-modes (primary-mode linked-mode &optional negate)
  "run this makro to enable `linked-mode' whenever `primary-mode' is activated. Use `negate' to get an reversed effect"
  (let ((advice-name (intern (concat (symbol-name linked-mode) "-link-around"))))
   `(progn
      (defadvice ,primary-mode (around ,advice-name (&optional arg))
        ,(concat (format "Around advice that automatically %s %s when %s is activated "
                         (if negate "disables" "enables")
                         (symbol-name linked-mode)
                         (symbol-name primary-mode)))
        ad-do-it
        (if (null ad-return-value)
            (,linked-mode ,(if negate 1 0))
          (progn
            (,linked-mode ,(if negate 0 1))
            (message "enabling..."))))
      (ad-activate ',primary-mode))))
#+END_SRC
** various
#+BEGIN_SRC elisp
  ;;; http://www.emacswiki.org/emacs/InsertDate
  (defun rk/insert-date (prefix)
    "Insert the current date. With prefix-argument, use ISO format. With
     two prefix arguments, write out the day and month name."
    (interactive "P")
    (let ((format (cond
                   ((not prefix) "%A, %d. %B %Y")
                   ((equal prefix '(4)) "%Y-%m-%d")
                   ((equal prefix '(16)) "%d.%m.%Y")))
          (system-time-locale "en_US"))
      (insert (format-time-string format))))

  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  (defun rk/browse-url-or-current-file ()
    "either opens the url at point or the current file"
    (interactive)
    (browse-url (or (browse-url-url-at-point)
                    (concat "file://" (file-truename buffer-file-name)))))

  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  (defun rk/insert-name-email ()
    (interactive)
    (insert "Robert Krahn <robert.krahn@gmail.com>"))
#+END_SRC
** tests
#+BEGIN_SRC elisp
  (defmacro rk/test-with-temp-buffer-do (buffer-name body)
    `(unwind-protect
         (with-current-buffer (get-buffer-create ,buffer-name)
           ,body)
      (kill-buffer ,buffer-name)))
  
  (ert-deftest rk/activate-region-test ()
    (with-temp-buffer
      (insert "foo\nbar\nbaz")
      (rk/activate-region 2 6)
      (should (equal "oo\nb" (buffer-substring-no-properties (region-beginning) (region-end))))))
  
  (ert-deftest rk/current-line-string-test ()
    (with-temp-buffer
      (insert "foo bar\nbaz\nzork")
      (goto-line 2) (forward-char 1)
      (should (equal "baz" (rk/current-line-string)))))
  
  ;; (rk/do-for-each-line-test)
  (ert-deftest rk/do-for-each-line-test ()
    (with-temp-buffer
     "--rk-do-for-each-line-test-buffer--"
     (let (result)
       ;; start: 1 end: 12 + 1
       (insert "ha\nll\no\nwelt")
       (goto-char (+ 12 1))
  
       (setq result (rk/do-for-each-line-in-region 'identity))
       (assert (equal '("ha" "ll" "o" "welt") result) t "no lines without setting mark")
  
       (set-mark 1)
  
       (setq result (length (rk/do-for-each-line-in-region 'identity)))
       (assert (equal 4 result) t "line no not correct")
  
       (setq result (rk/do-for-each-line-in-region (lambda (line) (number-to-string (length line)))))
       (assert (equal '("2" "2" "1" "4") result) t "length of lines not correct")
  
       (assert (equal "2\n2\n1\n4" (buffer-string)) t "buffer contents not ok")
  
       (setq result (rk/do-for-each-line-in-region (lambda (line count) (number-to-string count))))
       (assert (equal '("0" "1" "2" "3") result) t "call with count not ok"))))
  
  
  (ert-deftest rk/string-match-test ()
    (let ((string "foo bar baz")
          (regexp "\\w+ \\(\\w+\\) \\w+"))
     (assert (equal (rk/string-match string regexp '(1)) '("bar")) t "list return")
     (assert (equal (rk/string-match string regexp 1) "bar") t "single return")
     (assert (equal (rk/string-match "foo" "zork" 1) nil) t "no match")))
  
  
  (ert-deftest rk/split-buffer-test ()
    (rk/test-with-temp-buffer-do
     "rk-split-buffer-test buffer"
     (let ((buffer-content "foo\n------\nbar")
           (create-file-call-n 0))
       (insert buffer-content)
       (flet ((rk/create-file (filename content) (progn
                                                   (setq create-file-call-n (1+ create-file-call-n))
                                                   (assert (string= filename "baz") t "file name not ok")
                                                   (assert (string-match "foo\\|bar" content) t (concat "content not ok: " content)))))
         (rk/split-buffer-and-save-parts "rk-split-buffer-test buffer" (lambda (content) "baz"))
         (assert (equal 2 create-file-call-n) t "create file not called two times")))))
  
#+END_SRC
* org-mode

#+BEGIN_SRC emacs-lisp
  (setq org-log-done t
        org-completion-use-ido nil
        org-edit-timestamp-down-means-later t
        org-agenda-start-on-weekday t
        org-agenda-span 14
        org-agenda-include-diary t
        org-agenda-window-setup 'current-window
        org-fast-tag-selection-single-key nil
        org-export-kill-product-buffer-when-displayed t
        org-tags-column 80
        org-src-tab-acts-natively t
        org-confirm-babel-evaluate nil
        org-src-window-setup 'current-window)

  ;; active Babel languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t)
     (emacs-lisp . t)
     (js . t)))

  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)

  ;; (eval-after-load 'org
  ;;   '(progn
  ;;      (org-defkey org-mode-map (kbd "<S-return>") 'rk/open-line-above)))
#+END_SRC

* shell scripting
** scripts
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
** emacs & shell
#+BEGIN_SRC emacs-lisp
  ;;; getting the system shell vars I care about into emacs
  (defmacro rk/set-env-from-system-shell (&rest var-names)
    "query var-names via `env' command from system shell and
  generate a bunch of `setenv' statements from it"
    `(progn
       ,@(let* ((cmd (format "$SHELL --login -i -c 'env | egrep \"^(%s)=\"'"
                             (rk/string-join var-names "|")))
                (shell-out (shell-command-to-string cmd))
                (lines (split-string shell-out "[\n]+"))
                (vars-and-vals (rk/filter (lambda (pair) (and pair (car pair) (cadr pair)))
                   (mapcar
                                (lambda (line) (rk/string-match line "\\([^=]+\\)=\\(.*\\)" '(1 2)))
                                lines))))
           (mapcar (lambda (var-value) `(setenv ,@var-value)) vars-and-vals))))
  
  (when (and *is-a-mac* window-system)
    (rk/set-env-from-system-shell
     "PATH" "MANPATH"
     "CPATH" "PKG_CONFIG_PATH" "C_INCLUDE_PATH" "CPLUS_INCLUDE_PATH" "PYTHONPATH"
     "LDFLAGS" "CFLAGS" "LIBS"  "DYLD_LIBRARY_PATH"
     "JAVA_HOME" "CLOJURESCRIPT_HOME" "DOCKER_HOST" "TESSDATA_PREFIX"
     "ZSH_PROFILE"
     "ARDUINO_DIR" "ARDMK_DIR"
     "NOTES" "LIVELY" "WEBWERKSTATT"))
  
  (setq exec-path (split-string (getenv "PATH") path-separator))
  (setenv "PAGER" "/bin/cat")
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; tramp
  (setq tramp-default-user-alist '(("\\`smb\\'" nil nil)
                                   ("\\`\\(?:fcp\\|krlogin\\|r\\(?:cp\\|emcp\\|sh\\)\\|telnet\\)\\'" nil "robert")
                                   ("\\`\\(?:ksu\\|su\\(?:do\\)?\\)\\'" nil "root")
                                   ("\\`\\(?:socks\\|tunnel\\)\\'" nil "robert")
                                   ("\\`synce\\'" nil nil)
                                   ("\\`ssh\\'" "nil" "robert")))

  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  (defun rk/shell-exec-and-replace-lines ()
    (interactive)
    (rk/do-for-each-line-in-region 'shell-command-to-string))

  (defun rk/shell-exec-expression (&optional print-it)
    (interactive "p")
    (let* ((start (if (region-active-p) (mark) (line-beginning-position)))
           (end (if (region-active-p) (point) (line-end-position)))
           (lines (split-string (buffer-substring-no-properties start end) "[\n]+"))
           (command (rk/string-join lines " \\\n"))
           (result (shell-command-to-string command)))
      (if (= 4 print-it)
          (let (deactivate-mark)
            (push-mark nil nil t)
            (insert result))
        (slime-flash-region start end 0.7))))

  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  ;;; eshell

  (defun eshell/edit (file)
    (find-file file))


  (defun eshell/ll (&rest ARGS)
    (eshell/ls (cons "-l" ARGS)))

  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  (custom-set-variables
   '(Man-notify-method (quote pushy)))

  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  ;;; doesn't really belong here
  (set-default 'comint-scroll-to-bottom-on-input t)
  (set-default 'comint-scroll-to-bottom-on-output t)
  (set-default 'comint-move-point-for-output t)

  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  (defun rk/visit-term-buffer ()
    "Create or visit a terminal buffer."
    (interactive)
    (if (not (get-buffer "*ansi-term*"))
        (progn
          (ansi-term (getenv "SHELL")))
      (switch-to-buffer "*ansi-term*")))

  (add-hook 'term-mode-hook (lambda () (setq show-trailing-whitespace nil)))
  ;; (add-hook 'term-mode-hook (lambda () (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix)))
  ;; (remove-hook 'term-mode-hook (car term-mode-hook))

#+END_SRC
* misc
** windows
#+BEGIN_SRC emacs-lisp
(winner-mode 1) ;; C-c <left>, C-c <right> for back/forth window layout

;;; resize windows interactively, from http://www.emacswiki.org/emacs/WindowResize
(defun resize-window (&optional arg)    ; Hirose Yuuji and Bob Wiener
  "*Resize window interactively."
  (interactive "p")
  (if (one-window-p) (error "Cannot resize sole window"))
  (or arg (setq arg 10))
  (let (c)
    (catch 'done
      (while t
    (message
     "h=heighten, s=shrink, w=widen, n=narrow (by %d);  1-9=unit, q=quit"
     arg)
    (setq c (read-char))
    (condition-case ()
        (cond
         ((= c ?h) (enlarge-window arg))
         ((= c ?s) (shrink-window arg))
         ((= c ?w) (enlarge-window-horizontally arg))
         ((= c ?n) (shrink-window-horizontally arg))
         ((= c ?\^G) (keyboard-quit))
         ((= c ?q) (throw 'done t))
         ((and (> c ?0) (<= c ?9)) (setq arg (- c ?0)))
         (t (beep)))
      (error (beep)))))
    (message "Done.")))

(global-set-key (kbd "<f6>") 'resize-window)
;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

(add-to-list 'same-window-regexps ".*")

;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

(eval-after-load "compile"
'(defun compilation-goto-locus (msg mk end-mk)
  "Jump to an error corresponding to MSG at MK.
All arguments are markers.  If END-MK is non-nil, mark is set there
and overlay is highlighted between MK and END-MK."
  ;; Show compilation buffer in other window, scrolled to this error.
  (let* ((from-compilation-buffer (eq (window-buffer (selected-window))
                  (marker-buffer msg)))
     ;; Use an existing window if it is in a visible frame.
     (pre-existing (get-buffer-window (marker-buffer msg) 0))
     (w (if (and from-compilation-buffer pre-existing)
        ;; Calling display-buffer here may end up (partly) hiding
        ;; the error location if the two buffers are in two
        ;; different frames.  So don't do it if it's not necessary.
        pre-existing
      (let ((display-buffer-reuse-frames t)
        (pop-up-windows t))
        ;; Pop up a window.
        (display-buffer (marker-buffer msg)))))
     (highlight-regexp (with-current-buffer (marker-buffer msg)
             ;; also do this while we change buffer
             (compilation-set-window w msg)
             compilation-highlight-regexp)))
;; Ideally, the window-size should be passed to `display-buffer' (via
;; something like special-display-buffer) so it's only used when
;; creating a new window.
(unless pre-existing (compilation-set-window-height w))

(switch-to-buffer (marker-buffer mk))

    ;; was
;; (if from-compilation-buffer
;;     ;; If the compilation buffer window was selected,
;;     ;; keep the compilation buffer in this window;
;;     ;; display the source in another window.
;;     (let ((pop-up-windows t))
;;       (pop-to-buffer (marker-buffer mk) 'other-window))
;;   (if (window-dedicated-p (selected-window))
;;       (pop-to-buffer (marker-buffer mk))
;;     (switch-to-buffer (marker-buffer mk))))
;; If narrowing gets in the way of going to the right place, widen.
(unless (eq (goto-char mk) (point))
  (widen)
  (goto-char mk))
(if end-mk
    (push-mark end-mk t)
  (if mark-active (setq mark-active)))
;; If hideshow got in the way of
;; seeing the right place, open permanently.
(dolist (ov (overlays-at (point)))
  (when (eq 'hs (overlay-get ov 'invisible))
    (delete-overlay ov)
    (goto-char mk)))

(when highlight-regexp
  (if (timerp next-error-highlight-timer)
      (cancel-timer next-error-highlight-timer))
  (unless compilation-highlight-overlay
    (setq compilation-highlight-overlay
      (make-overlay (point-min) (point-min)))
    (overlay-put compilation-highlight-overlay 'face 'next-error))
  (with-current-buffer (marker-buffer mk)
    (save-excursion
      (if end-mk (goto-char end-mk) (end-of-line))
      (let ((end (point)))
    (if mk (goto-char mk) (beginning-of-line))
    (if (and (stringp highlight-regexp)
         (re-search-forward highlight-regexp end t))
        (progn
          (goto-char (match-beginning 0))
          (move-overlay compilation-highlight-overlay
                (match-beginning 0) (match-end 0)
                (current-buffer)))
      (move-overlay compilation-highlight-overlay
            (point) end (current-buffer)))
    (if (or (eq next-error-highlight t)
        (numberp next-error-highlight))
        ;; We want highlighting: delete overlay on next input.
        (add-hook 'pre-command-hook
              'compilation-goto-locus-delete-o)
      ;; We don't want highlighting: delete overlay now.
      (delete-overlay compilation-highlight-overlay))
    ;; We want highlighting for a limited time:
    ;; set up a timer to delete it.
    (when (numberp next-error-highlight)
      (setq next-error-highlight-timer
        (run-at-time next-error-highlight nil
                 'compilation-goto-locus-delete-o)))))))
(when (and (eq next-error-highlight 'fringe-arrow))
  ;; We want a fringe arrow (instead of highlighting).
  (setq next-error-overlay-arrow-position
    (copy-marker (line-beginning-position)))))))
#+END_SRC

** frames
Suppress GUI features
#+BEGIN_SRC emacs-lisp
(setq use-file-dialog nil)
(setq use-dialog-box nil)
(setq inhibit-startup-screen t)
(setq inhibit-startup-echo-area-message t)
(when (fboundp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (fboundp 'set-scroll-bar-mode)
  (set-scroll-bar-mode nil))
#+END_SRC
*** Mac OS fullscreen
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'ns-toggle-fullscreen)
    (defadvice ns-toggle-fullscreen (after mark-full-screen activate)
      (set-frame-parameter nil
                           'is-full-screen
                           (not (frame-parameter nil 'is-full-screen)))))

  (when (and *is-cocoa-emacs* (not (fboundp 'ns-toggle-fullscreen)))
    (defun ns-toggle-fullscreen ()
      "Toggle full screen"
      (interactive)
      ;; (debug)
      (set-frame-parameter
       nil 'fullscreen
       (when (not (frame-parameter nil 'fullscreen)) 'fullscreen))))

  (when (fboundp 'ns-toggle-fullscreen)
    ;; Command-Option-f to toggle fullscreen mode
    (global-set-key (kbd "M-s-ƒ") 'ns-toggle-fullscreen))
#+END_SRC
* project support
** find stuff
#+BEGIN_SRC emacs-lisp
  ;;; adapted from textmate.el

  ;;;;;;;;;;;;
  ;; helper ;;
  ;;;;;;;;;;;;

  ;; http://snipplr.com/view/18683/stringreplace/
  (defun rk/string-replace (this withthat in)
    "replace THIS with WITHTHAT' in the string IN"
    (with-temp-buffer
      (insert in)
      (goto-char (point-min))
      (while (search-forward this nil t)
        (replace-match withthat nil t))
      (buffer-substring (point-min) (point-max))))

  ;;;;;;;;;;;;;;;;;;
  ;; project root ;;
  ;;;;;;;;;;;;;;;;;;
  (defvar *rk/project-root* nil
    "Used internally to cache the project root.")

  (defvar *rk/project-roots* '(".git" ".hg" "Rakefile" "Makefile" "README" "README.md" "build.xml" ".emacs-project")
  "The presence of any file/directory in this list indicates a project root.")

  (defun rk/find-project-root (&optional root)
    "Determines the current project root by recursively searching
  for an indicator. If no project indicator is found it will return
  `default-directory'"
    (when (null root) (setq root default-directory))
    (cond
     ((rk/root-matches root *rk/project-roots*)
      (expand-file-name root))
     ((equal (expand-file-name root) "/") default-directory)
     (t (rk/find-project-root (concat (file-name-as-directory root) "..")))))

  (defun rk/project-root ()
    "Returns the current project root."
    (when (or
           (null *rk/project-root*)
           (not (string-match *rk/project-root* default-directory)))
      (let ((root (rk/find-project-root)))
        (if root
            (setq *rk/project-root* (expand-file-name (concat root "/")))
          (setq *rk/project-root* nil))))
    *rk/project-root*)

  ;;; -=-=-=-=-=-=-=-=-=-

  (defun rk/root-match(root names)
    (member (car names) (directory-files root)))

  (defun rk/root-matches(root names)
    (if (rk/root-match root names)
        (rk/root-match root names)
        (if (eq (length (cdr names)) 0)
            'nil
            (rk/root-matches root (cdr names)))))

  ;;;;;;;;;;;;;;;;
  ;; find files ;;
  ;;;;;;;;;;;;;;;;
  (defun rk/find-project-files (root &optional max-depth)
    "Finds all files in a given 'project'. What a project is, is determined by textmate.
  Contrary to 'textmate-find-project-files' this search uses find and it's prune option to
  not recurse into dirs that should be ignored. The shell command  outputed is sth like
  find -E . \\( -type f -a -not \\( -name \"*#\" -o -name \".gitignore\" -o -name \"*~\" -o -name \"*.lock\" -o -name \"*.DS_Store\" -o -name \"*elc\" \\) \\) -o -type d \\( -name \".git\" -o -name \".svn\" -o -name \"vendor\" -o -name \"fixtures\" -o -name \"tmp\" -o -name \"log\" -o -name \"classes\" -o -name \"build\" -o -name \"_temp\" \\) -not -prune | sed 's:/Users/robert/robertkrahn.org/notes//::'"
    (flet ((as-name-arg (string) (concat "-name \"" string "\""))
           ;; when rk/find-file-ignores = '("*#" ".gitignore") this
           ;; outputs "-name \"*#\" -o -name \".gitignore\""
           (make-ignore-args (ignore-list) (mapconcat 'as-name-arg ignore-list " -o ")))
      (split-string (shell-command-to-string
                     (concat "find -E " root " \\( -type f -a -not \\( "
                             (make-ignore-args rk/find-file-ignores)
                             " \\) \\) -o -type d \\( "
                             (make-ignore-args rk/find-dir-ignores)
                             " \\) -not -prune "
                             (if max-depth (concat "-maxdepth " (number-to-string max-depth)) "")
                             " | sed 's:" *rk/project-root* "/::'")) "\n" t)))

  ;; (makunbound 'rk/find-project-files-cache)
  (defvar rk/find-project-files-cache nil
    "alist holding dir - project file maps")

  (defvar rk/find-project-files-cache-invalidation-time 60
    "in secs")

  (defun rk/find-project-files-cached (root &optional max-depth)
    ""
    (let* ((key (expand-file-name root))
           (cache rk/find-project-files-cache)
           (entry (assoc key rk/find-project-files-cache)))
      (or entry
          (lexical-let* ((entry-lookup (rk/find-project-files root max-depth))
                         (cache-item `(,key . ,entry-lookup)))
            (push cache-item rk/find-project-files-cache)
            (run-with-timer
             rk/find-project-files-cache-invalidation-time nil
             (lambda () (setq rk/find-project-files-cache (delete cache-item rk/find-project-files-cache))))
            entry-lookup))))

  (setq
   rk/find-file-ignores '("*#" ".gitignore" "*~" "*.lock" "*.DS_Store" "*elc" "*.xcodeproj" "*.nib" "*.framework" "*.app" "*.pbproj" "*.pbxproj" "*.xcode" "*.xcodeproj" "*.bundle" "*.pyc" "*.elc")
   rk/find-dir-ignores '(".git" ".svn" "vendor" "fixtures" "tmp" "log" "classes" "build" "*_temp"))

  (defun rk/project-files (root &optional max-depth)
    (if root
        (sort
         (rk/find-project-files-cached root max-depth)
         '(lambda (a b) (< (length a) (length b))))
      nil))

#+END_SRC
* grep
#+BEGIN_SRC emacs-lisp
;; writable grep
(require 'wgrep)
(setq wgrep-auto-save-buffer t)
#+END_SRC
* dired

#+BEGIN_SRC emacs-lisp
;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
;;; wdired
(eval-after-load "wdired"
  '(progn (define-key dired-mode-map (kbd "e") 'wdired-change-to-wdired-mode)
          (setq wdired-allow-to-change-permissions t)))
#+END_SRC

#+RESULTS:

** languages
*** lisp
**** general lispy stuff
#+BEGIN_SRC emacs-lisp
  (autoload 'enable-paredit-mode "paredit")
  
  (defun maybe-map-paredit-newline ()
    (unless (or (eq major-mode 'inferior-emacs-lisp-mode) (minibufferp))
      (local-set-key (kbd "RET") 'paredit-newline)))
  
  (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline)
  
  (eval-after-load 'paredit
    '(progn
       ;; These are handy everywhere, not just in lisp modes
       (global-set-key (kbd "M-(") 'paredit-wrap-round)
       (global-set-key (kbd "M-[") 'paredit-wrap-square)
       (global-set-key (kbd "M-{") 'paredit-wrap-curly)
  
       (global-set-key (kbd "M-)") 'paredit-close-round-and-newline)
       (global-set-key (kbd "M-]") 'paredit-close-square-and-newline)
       (global-set-key (kbd "M-}") 'paredit-close-curly-and-newline)
  
       (dolist (binding (list (kbd "C-<left>") (kbd "C-<right>")
                              (kbd "C-M-<left>") (kbd "C-M-<right>")))
         (define-key paredit-mode-map binding nil))
  
       ;; Disable kill-sentence, which is easily confused with the kill-sexp
       ;; binding, but doesn't preserve sexp structure
       (define-key paredit-mode-map [remap kill-sentence] nil)
       (define-key paredit-mode-map [remap backward-kill-sentence] nil)))
  
  
  ;; Compatibility with other modes
  
  (add-hook 'minibuffer-setup-hook 'conditionally-enable-paredit-mode)
  
  (defvar paredit-minibuffer-commands '(eval-expression
                                        pp-eval-expression
                                        eval-expression-with-eldoc)
    "Interactive commands for which paredit should be enabled in the minibuffer.")
  
  (defun conditionally-enable-paredit-mode ()
    "Enable paredit during lisp-related minibuffer commands."
    (if (memq this-command paredit-minibuffer-commands)
        (enable-paredit-mode)))
  
  (defun lisp-setup ()
    "Enable features useful in any Lisp mode."
    (enable-paredit-mode)
    (turn-on-eldoc-mode))
  
  (let* ((lispy-hooks '(emacs-lisp-mode-hook
                        ielm-mode-hook
                        lisp-mode-hook
                        inferior-lisp-mode-hook
                        pareditlisp-interaction-mode-hook
                        clojure-mode-hook)))
    (dolist (hook lispy-hooks)
      (add-hook hook 'lisp-setup)))
  
  
  (define-key emacs-lisp-mode-map (kbd "C-x C-a") 'pp-macroexpand-last-sexp)
  
  ;; ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (defun rk/bounds-of-defun ()
    "uses beginning-of-defun and end-of-defun to determine the bounds"
    (save-excursion
      `(,(progn (beginning-of-defun) (point)) . ,(progn (end-of-defun) (point)))))
  
  (defun rk/flash-region (start end &optional timeout)
    "Temporarily highlight region from START to END."
    (let ((overlay (make-overlay start end)))
      (overlay-put overlay 'face 'secondary-selection)
      (run-with-timer (or timeout 0.2) nil 'delete-overlay overlay)))
  
  (defun rk/eval-defun-flash ()
    (interactive)
    (let* ((bounds (rk/bounds-of-defun))
           (start (car bounds))
           (end (cdr bounds)))
      (rk/flash-region start end 0.7)
      (eval-region start end t)))
  
  (define-key emacs-lisp-mode-map (kbd "M-S-SPC") 'rk/eval-defun-flash)
#+END_SRC

**** elisp
#+BEGIN_SRC elisp
  ;; Elisp go-to-definition with M-. and back again with M-,
  (autoload 'elisp-slime-nav-mode "elisp-slime-nav")
  (add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t)))
  (eval-after-load 'elisp-slime-nav '(diminish 'elisp-slime-nav-mode))
#+END_SRC

**** clojure
***** cider
#+BEGIN_SRC elisp
  ;;; see https://github.com/clojure-emacs/cider#configuration
  
  (require 'cider)
  (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
  (add-hook 'cider-repl-mode-hook 'paredit-mode)
  
  (setq cider-popup-stacktraces-in-repl t)
  (setq cider-repl-pop-to-buffer-on-connect nil)
  (setq cider-history-file "~/.emacs.d/cider-history")
  
  (defvar rk/cider-key-map (make-keymap) "my clojure keys")
  
  ;; ;; nrepl setup
  ;; (setq cider-hide-special-buffers t)
  
  ;;; my cider keys
  (defun rk/cider-print-and-mark (arg)
    (interactive "P")
    (push-mark (point) t t)
    (if arg
        (cider-pprint-eval-last-expression)
        (cider-eval-print-last-sexp)))
  
  (define-key rk/cider-key-map (kbd "C-x C-p") 'rk/cider-print-and-mark)
  (define-key rk/cider-key-map (kbd "s-p") 'rk/cider-print-and-mark)
  (define-key rk/cider-key-map (kbd "s-d") 'cider-eval-last-expression)
  (define-key rk/cider-key-map (kbd "s-i") 'cider-inspect)
  (define-key rk/cider-key-map (kbd "s-I") 'cider-src)
  
  (define-minor-mode rk/cider-minor-mode
    "A minor mode so that my key settings override annoying major modes."
    nil " rkclj" rk/cider-key-map)
  
  (defun rk/turn-on-cider-minor-mode () (rk/cider-minor-mode 1))
  
  ;; (add-hook 'cider-mode-hook 'rk/turn-on-cider-minor-mode t t)
  (add-hook 'cider-mode-hook 'rk/turn-on-cider-minor-mode)
  
#+END_SRC

* version control
** magit
#+BEGIN_SRC emacs-lisp
  (setq magit-save-some-buffers nil
        magit-process-popup-time 10
        magit-completing-read-function 'magit-ido-completing-read
        magit-log-auto-more t
        magit-log-cutoff-length 300)

  (defun magit-status-somedir ()
    (interactive)
    (let ((current-prefix-arg t))
      (magit-status default-directory)))

  (define-key vc-prefix-map (kbd "SPC") 'magit-status-somedir)
#+END_SRC
* auto-complete
#+BEGIN_SRC emacs-lisp
  (require 'auto-complete)
  (require 'auto-complete-config)
  (global-auto-complete-mode t)
  (setq ac-auto-start nil)
  (setq ac-dwim nil) ; To get pop-ups with docs even if a word is uniquely completed
  (setq ac-quick-help-delay 0.3)
  (setq ac-use-fuzzy nil)
  (define-key ac-completing-map (kbd "C-n") 'ac-next)
  (define-key ac-completing-map (kbd "C-p") 'ac-previous)
  
  (setq tab-always-indent t)  ;; use 'complete when auto-complete is disabled
  (add-to-list 'completion-styles 'initials t)
  
  ;; hook AC into completion-at-point
  (defun set-auto-complete-as-completion-at-point-function ()
    (setq completion-at-point-functions '(auto-complete)))
  (add-hook 'auto-complete-mode-hook 'set-auto-complete-as-completion-at-point-function)
  
  
  (set-default 'ac-sources
               '(ac-source-dictionary
                 ac-source-words-in-buffer
                 ac-source-words-in-same-mode-buffers
                 ac-source-words-in-all-buffer))
  
  (dolist (mode '(magit-log-edit-mode log-edit-mode org-mode text-mode haml-mode
                                      sass-mode yaml-mode csv-mode espresso-mode haskell-mode
                                      html-mode sh-mode clojure-mode
                                      lisp-mode textile-mode markdown-mode tuareg-mode
                                      js3-mode css-mode less-css-mode
                                      octave-mode))
    (add-to-list 'ac-modes mode))
  
#+END_SRC
* projectile
#+BEGIN_SRC elisp
  (require 'projectile)
  
  (defun rk/remove-projectile-prefix ()
    (setq minor-mode-map-alist
          (-remove
           (lambda (x) (eq (car x) 'projectile-mode))
           minor-mode-map-alist)))
  
  (rk/remove-projectile-prefix)
  
  (setq projectile-keymap-prefix (kbd "C-c C-p"))
  (projectile-global-mode)
  ;; (lookup-key global-map (kbd "C-c p"))
  
  ;; (projectile-global-mode -1)
  (setq projectile-indexing-method 'native)
  (setq projectile-enable-caching t)
  
  ;;; projectile everywhere
  ;; (setq projectile-require-project-root nil)
  
  ;; (global-set-key (kbd "C-c h") 'helm-projectile)
  
#+END_SRC
* helm
** basics
#+BEGIN_SRC emacs-lisp
  (require 'helm-config)
  (require 'helm-imenu)
  (helm-mode 1)
  
  (setq helm-idle-delay 0.3
        helm-quick-update t
        helm-candidate-number-limit 400
        ;; helm-candidate-number-limit nil
        helm-su-or-sudo "sudo"
        helm-allow-skipping-current-buffer nil
  
        helm-samewindow nil ;; already covered by my window init
        enable-recursive-minibuffers t
        helm-truncate-lines t
        ;; no auto update when listing files
        helm-ff-auto-update-initial-value nil)
  
  (helm-adaptative-mode 1)
  
  (defun rk/helm-symbols (arg)
    (interactive "P")
    ;; see `helm-occur'
    (let ((init (and (equal arg '(4)) (thing-at-point 'symbol)))
          (buffers (list (current-buffer)))
          (helm-multi-occur-buffer-list (list (buffer-name (current-buffer))))
          ;; (helm-compile-source-functions
          ;;  ;; rule out helm-match-plugin because the input is one regexp
          ;;  (delq 'helm-compile-source--match-plugin
          ;;        (copy-sequence helm-compile-source-functions)))
          )
      (helm-occur-init-source)
      (helm-attrset 'name "Occur" helm-c-source-occur)
      (helm :prompt "Search for symbol: "
            :input init
            :default (thing-at-point 'symbol)
            :sources '(helm-c-source-imenu
                       helm-c-source-occur)
            :buffer "*helm symbols*")))
  
  (require 'helm-projectile)
  
  (defun rk/helm-buffers-and-files ()
    (interactive)
    (let* ((helm-ff-transformer-show-only-basename nil)
           (basic-sources '(helm-source-buffers-list
                           helm-c-source-recentf
                           helm-c-source-bookmarks))
           (sources (if (projectile-project-p)
                        (-concat helm-projectile-sources-list '(helm-c-source-bookmarks))
                      basic-sources)))
      (helm
       :prompt "Switch to: "
       :candidate-number-limit 20
       :sources sources)))
  
#+END_SRC

* flycheck
#+BEGIN_SRC elisp
  (add-hook 'after-init-hook #'global-flycheck-mode)

  (defun rk/flycheck-display-error-messages (errors)
    ;; (message "test")
    (-when-let (messages (-keep #'flycheck-error-message errors))
      (when (flycheck-may-use-echo-area-p)
        ;; (display-message-or-buffer (s-join "\n\n" messages)
        ;;                            flycheck-error-message-buffer)
        (display-message-or-buffer (s-join "\n\n" messages)
                                   flycheck-error-message-buffer t))))

  (eval-after-load 'flycheck
    '(progn
       (setq flycheck-checkers (delq 'emacs-lisp-checkdoc flycheck-checkers))
       (setq flycheck-display-errors-function 'rk/flycheck-display-error-messages)))
#+END_SRC

* social
** erc
#+BEGIN_SRC elisp
  (require 'erc)

  (setq erc-hide-list '("JOIN" "PART" "QUIT")
        erc-nick "rksm"
        erc-notifications-mode t
        erc-input-line-position -3)

  (erc-autojoin-mode t)
  (setq erc-autojoin-channels-alist
    '((".*\\.freenode.net" "#emacs" "#Node.js" "#clojure" "#ace")))

  (defun rk/erc-make-frame ()
    (interactive)
    (make-frame)
    (rk/erc-setup-windows))

  (defun rk/erc-setup-windows ()
    (interactive)
    (let ((erc-buffers (butlast (erc-buffer-list) 1)))
      ;; create new windows for erc
      (dotimes (i (- (length erc-buffers) 1))
        (split-window-vertically))
      ;; assign erc buffers to new windows
      (loop for win being the windows for buf in erc-buffers do (set-window-buffer win buf))
      (balance-windows)))

  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; znc
  ;;; /server robert.krahn.org 6666 rksm:<pass>
  (add-to-list 'load-path (concat (expand-file-name "~/.emacs.d/site-lisp/") "znc"))
  (require 'znc)
  (setq znc-servers
        '(("robertkrahn.org" 6666 nil ((network-slug "rksm" "tebor1")))))

  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; growl

  (defvar growlnotify-command (executable-find "growlnotify") "The path to growlnotify")

  (when growlnotify-command

    (defun growl (title message)
      "Shows a message through the growl notification system using
   `growlnotify-command` as the program."
      (flet ((encfn (s) (encode-coding-string s (keyboard-coding-system))) )
        (let* ((process (start-process "growlnotify" nil
                                       growlnotify-command
                                       (encfn title)
                                       "-a" "Emacs"
                                       "-n" "Emacs")))
          (process-send-string process (encfn message))
          (process-send-string process "\n")
          (process-send-eof process)))
      t)

    (defun rk/erc-nick-mentioned-hook (match-type nick message)
      "Shows a growl notification, when user's nick was mentioned. If the buffer is currently not visible, makes it sticky."
      (unless (posix-string-match "^\\** *Users on #" message)
        (growl
         (concat "ERC: name mentioned on: " (buffer-name (current-buffer)))
         message)))

    (add-hook 'erc-text-matched-hook 'rk/erc-nick-mentioned-hook))
#+END_SRC
* javascript
** swank-js
*** load
#+BEGIN_SRC elisp
  (require 'slime-autoloads)
  (slime-setup '(slime-repl slime-js))
  (require 'slime-js)
  (setq slime-net-coding-system 'utf-8-unix)
#+END_SRC
*** swank-js nodes server commands
#+BEGIN_SRC elisp :tangle no
  (defvar rk/slime-js-node-buffer-name nil
    "node.js buffer for running slime-js socket.io server")
  
  (defun rk/slime-js-kill-node ()
    (let ((buf (get-buffer rk/slime-js-node-buffer-name)))
      (when buf
        (while (get-buffer-process buf)
          (kill-process (get-buffer-process buf))
          (sit-for 0 400))
        (kill-buffer buf))))
  
  (defun rk/slime-js-start-node ()
    (setq rk/slime-js-node-buffer-name "node slime-js")
    (rk/slime-js-kill-node)
    (async-shell-command
     (concat "node ~/.emacs.d/site-lisp/swank-js/swank.js")
     (get-buffer-create rk/slime-js-node-buffer-name)))
  
  (defun rk/slime-js-start ()
    (interactive)
    (let ((buf (current-buffer))
          (win (get-buffer-window)))
      (rk/slime-js-start-node)
      (sleep-for 0 600)              ; wait for node to startup
      (slime-connect "127.0.0.1" 4005 'utf-8-unix)
      (run-with-timer 0.3 nil 'set-window-buffer win buf)))
  
  (defun rk/slime-js-stop ()
    (interactive)
    (let ((node-buf (get-buffer rk/slime-js-node-buffer-name))
          (slime-buf (get-buffer "*slime-repl JS*"))
          (slime-log-buf (get-buffer "*slime-events*")))
      (rk/slime-js-kill-node)
      (dolist (buf (list slime-buf slime-log-buf))
        (when buf (kill-buffer buf)))))
#+END_SRC

*** slime-js JS evaluation extensions
for sending arbitrary expressions, inspecting, printing, etc.

#+BEGIN_SRC elisp :tangle no
  (defun rk/slime-js-send-start-end (from to &optional transform-string-func callback)
    "send the js code between start and end to the slime REPL"
    (save-excursion
      (slime-flash-region from to 0.7)
      (setq transform-string-func (or transform-string-func 'identity))
      (lexical-let* ((string-to-send (funcall transform-string-func
                                              (buffer-substring-no-properties from to)))
                     (cb callback))
        (rk/slime-js-eval-with-custom-context
         string-to-send
         `(lambda (v)
            ,(when *rk/slime-js-print-result-p* '(rk/slime-js-print-result v))
            ,(when cb `(funcall ,cb (plist-get v :values))))))))
  
  (defun rk/slime-js-send-region-or-last-sexp (region-start region-end &optional transform-string-func callback)
    "Send the previous sexp to the slime repl"
    (interactive "r")
    (let ((start (if (region-active-p) region-start (line-beginning-position)))
          (end (if (region-active-p) region-end (line-end-position))))
      (rk/slime-js-send-start-end start end transform-string-func callback)))
  
  (defun rk/slime-js-send-defun ()
    (interactive)
    (save-excursion
      (let (*rk/slime-js-print-result-p*)
        (js3-mark-defun)
        (call-interactively 'rk/slime-js-send-region-or-last-sexp)
        ;; (call-interactively slime-js-send-region)
        )))
  
  (defvar rk/slime-js-inspect-code
    "var inspectFunc = (function(exprs) {
      for (var j = 0; j < exprs.length; j++) {
          if (eval('typeof ' + exprs[j]) === 'function') return eval(exprs[j]);
      };
  })(['$i', 'i', 'inspect', '(function(o) { return o; })']);inspectFunc(%s);"
    "The JavaScript code to run for creating an inspect
         representation of an evaluated expression.")
  
  (defun rk/slime-js-send-and-inspect (region-start region-end)
    "Send the previous sexp to the slime repl"
    (interactive "r")
    (rk/slime-js-send-region-or-last-sexp
     region-start region-end
     (lambda (string) (format rk/slime-js-inspect-code string))))
  
  (makunbound 'rk/slime-js-send-string-sync)
  (defun rk/slime-js-send-string-sync (string)
    "Send and eval the string, wait for result."
    (interactive "sJS expression: ")
    (lexical-let* (sync-result
                   (start (current-time))
                   (timeout (seconds-to-time 1)))
      (rk/slime-js-eval-with-custom-context
       string
       (lambda (v)
         (setq sync-result (plist-get v :values))))
      (while (and (not sync-result) (time-less-p (time-since start) timeout))
        (sit-for 0.05))
      sync-result))
  
  (defun rk/slime-js-send-buffer ()
    "Send the entire buffer to the slime repl"
    (interactive)
    (rk/slime-js-send-start-end (point-min) (point-max)))
  
  (defcustom *rk/slime-js-print-result-p* t
    "whether the result of the evaluated javascript is
  to be inserted in the current buffer"
    :group 'slime-js)
  
  (make-variable-buffer-local '*rk/slime-js-print-result-p*)
  
  (defun rk/slime-js-toggle-print-result ()
    (interactive)
    (progn
      (setq *rk/slime-js-print-result-p* (not *rk/slime-js-print-result-p*))
      (message (concat "printing JS is " (if *rk/slime-js-print-result-p* "on" "off")))))
  
  (defun rk/slime-js-print-result (result)
    (when *rk/slime-js-print-result-p*
      (let (deactivate-mark)
        (let ((result (plist-get result :values)))
          (push-mark nil t t)
          (insert (or result ""))
          (goto-char (point))))))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; custom "this", set what this is bound to when eval'ing expressions with
  ;; slime-js
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (defvar rk/slime-js-doit-context-expr-history nil)
  (defvar rk/slime-js-doit-context-expr nil
    "nil for not using a doit-context or something like 'that'.")
  
  (defun rk/slime-js-wrap-expr-for-doit-context-func (eval-expr doit-context-expr)
    "wraps the `eval-expr' in a directly called JS function bound
  to `doit-context-expr' and returns the result of the last
  statement of `eval-expr'."
    (if (equal "" eval-expr)
        nil
      (with-temp-buffer
        (insert eval-expr)
        (beginning-of-buffer)
        (let* ((ast (js3-parse))
               (last-expr (car (last (js3-node-child-list ast))))
               (last-expr-start (js3-node-abs-pos last-expr)))
          (goto-char last-expr-start)
          (insert "return ")
          (end-of-buffer)
          (insert (format "\n}).call(%s);" doit-context-expr))
          (beginning-of-buffer)
          (insert ";(function() {\n")
          (buffer-substring-no-properties (point-min) (point-max))))))
  
  (defun rk/slime-js-set-doit-context (doit-expr)
    "Set an expression like 'that' and when eval'ing you can use
  'this' in a toplevel form that will refer to 'that'."
    (interactive (list (read-from-minibuffer
                        "this expr: "
                        (car rk/slime-js-doit-context-expr-history) nil nil
                        'rk/slime-js-doit-context-expr-history)))
    (setq rk/slime-js-doit-context-expr (if (equal "" doit-expr) nil doit-expr)))
  
  (defun rk/slime-js-eval-with-custom-context (expr &optional cont)
    "Inserts `rk/slime-js-wrap-expr-for-doit-context-func' and
  calls `slime-js-eval'."
    (if (or (not expr) (equal "" expr))
        (message "js eval expr empty")
      (slime-js-eval
       (if rk/slime-js-doit-context-expr
           (rk/slime-js-wrap-expr-for-doit-context-func expr rk/slime-js-doit-context-expr)
         expr)
       cont)))
#+END_SRC

*** slime-js lively
these functions are used to implement something like the `lively' module
does for elisp: mark a JS expression in a buffer and provide ways of
evaling it

#+BEGIN_SRC elisp :tangle no
  (require 'cl)                           ; for `intersection'
  
  (defvar rk/slime-js-overlay-overlays nil
    "overlays that will eval the expression they are \"on\"")
  
  (defun rk/slime-js-overlay-make-or-update ()
    "Make the region evalable."
    (interactive)
    (if (region-active-p)
        (call-interactively 'rk/slime-js-overlay-make-overlay)
      (rk/slime-js-overlay-eval-all)))
  
  (defun rk/slime-js-overlay-make-overlay (start end)
    "Make the region evalable."
    (interactive "r")
    (let ((overlays-in-region (intersection (overlays-in start end) rk/slime-js-overlay-overlays)))
      (unless overlays-in-region
        (let ((o (make-overlay start end)))
          (add-to-list 'rk/slime-js-overlay-overlays o)
          (overlay-put o 'face '(:foreground "white" :background "tomato"))
          (rk/slime-js-overlay-eval o)
          o))))
  
  (defun rk/slime-js-overlay-remove-overlay-at-point ()
    (interactive)
    (let ((overlays (intersection (overlays-at (point)) rk/slime-js-overlay-overlays)))
      (rk/slime-js-overlay-remove-overlays overlays)))
  
  (defun rk/slime-js-overlay-remove-overlay (o)
    "remove overlay and make sure its not in the eval-overlay list anymore"
    (setq rk/slime-js-overlay-overlays (delq o rk/slime-js-overlay-overlays))
    (delete-overlay o))
  
  (defun rk/slime-js-overlay-remove-overlays (&optional overlays)
    "remove given or all overlays"
    (interactive)
    (let ((overlays-to-remove (or overlays rk/slime-js-overlay-overlays)))
      (dolist (o overlays-to-remove)
        (rk/slime-js-overlay-remove-overlay o))))
  
  (defun rk/slime-js-overlay-eval-all ()
    (interactive)
    (dolist (o rk/slime-js-overlay-overlays)
      (rk/slime-js-overlay-eval o)))
  
  (defun rk/slime-js-overlay-eval (overlay)
    (lexical-let ((o overlay))
      (with-buffer (overlay-buffer o)
        (rk/slime-js-eval-with-custom-context
         (buffer-substring-no-properties (overlay-start o) (overlay-end o))
         (lambda (eval-result)
           (let ((val (plist-get eval-result :values)))
             (overlay-put o 'display (format "%s" val))))))))
#+END_SRC

*** slime-js auto-complete
#+BEGIN_SRC elisp :tangle no
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; slime-js auto-complete extension for evaluating expressions and using JS
  ;; reflection for ac candidates
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (require 'ac-slime)
  (require 'init-text-nav) ;; FIXME for `rk/ac-slime-js-prev-partial-sexp'
  
  (defun rk/ac-slime-js-valid-start (string)
    (string-match-p "[0-9a-zA-Z_$\\.]" string))
  
  (defun rk/ac-slime-js-prev-partial-sexp ()
    "get the expression before (point)"
    (let* ((start (string (preceding-char)))
           (paren-or-quote (string-match-p "[\\)\"\']" start)))
      (cond
       ((rk/ac-slime-js-valid-start start)
        (goto-char (1- (point)))
        (point))
       (paren-or-quote (rk/smart-nav-backward) (point)))))
  
  (defun rk/ac-slime-js-prefix ()
    (interactive)
    (or (when (rk/ac-slime-js-valid-start (string (preceding-char)))
          (save-excursion
            (while (rk/ac-slime-js-prev-partial-sexp))
            (point))) (point)))
  
  (defun rk/ac-slime-js-prefix-string ()
    "Mainly used for debugging"
    (interactive)
    (buffer-substring-no-properties (rk/ac-slime-js-prefix) (point)))
  
  (defun rk/transform-simple-completion ()
    ;; (slime-simple-completions ac-prefix)
    (let ((result (slime-simple-completions ac-prefix)))
      (destructuring-bind (completions partial) result
        ;; completions
        (let ((transformed (mapcar
                            (lambda (s) (substring s (length ac-prefix)))
                            completions)))
          transformed))))
  
  ;; (makunbound 'ac-source-slime-js)
  (defun rk/setup-slime-js-ac-source ()
    (ac-define-source slime-js
      '((candidates . rk/transform-simple-completion)
        (prefix     . rk/ac-slime-js-prefix)
        (match      . (lambda (prefix candidates)
                        (mapcar (lambda (candidate) (concat prefix candidate)) candidates)))
        (requires   . 0))))
  
  (rk/setup-slime-js-ac-source)
#+END_SRC

*** hook stuff up
#+BEGIN_SRC elisp
  (eval-after-load "init-javascript"
    '(progn
       (add-mode-hook-for-js (lambda () (slime-js-minor-mode 1)))
       ;; (add-mode-hook-for-js (lambda () (add-to-list 'ac-sources 'ac-source-slime-js)))
       ))
#+END_SRC

** js3
#+BEGIN_SRC elisp
  
  (defvar js-modes '(js-mode js3-mode))
  
  (defmacro add-mode-hook-for-js (hook-function &optional append)
    `(dolist (hook '(js-mode-hook js3-mode-hook))
       (add-hook hook ,hook-function ,append)))
  
  (defcustom preferred-javascript-mode 'js3-mode
    "Javascript mode to use for .js files"
    :type 'symbol
    :group 'programming
    :options js-modes)
  
  (defvar preferred-mmm-javascript-mode 'js-mode)
  (defvar preferred-javascript-indent-level 4)
  
  ;; js-mode
  (setq js-flat-functions t)
  (setq js-indent-level preferred-javascript-indent-level)
  
  ;; (eval-after-load "js"
  ;;   '(progn
  ;;      (modify-syntax-entry ?- "_" js-mode-syntax-table)))
  
  ;; standard javascript-mode
  (setq javascript-indent-level preferred-javascript-indent-level)
  
  
  ;;; no annoying warnings (help-echos) that won't go away for js3
  (add-hook 'js3-mode-hook (lambda () (tooltip-mode -1)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;; use jshint
  ;; On-the-fly syntax checking
  ;; (require 'flymake-jshint)
  ;; (setq flymake-jslint-command "jshint")
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; js3 specific
  (eval-after-load "js3"
    '(progn
      (defadvice js3-end-of-line (before js3-eol-support-mark)
       "allow to set mark int transient mark mode"
       (rk/set-mark-on-shift-press))
  
      (defadvice js3-beginning-of-line (before js3-bol-support-mark)
       "allow to set mark int transient mark mode"
       (rk/set-mark-on-shift-press))
  
      ;; (defadvice js3-mode-create-imenu-index (after js3-lively-imneu-defs)
      ;;   "Add Lively class/method/object defs into return value for `imenu--index-alist'."
      ;;   ;; store into this value to change return
      ;;   ad-return-value)
  
      (ad-activate 'js3-end-of-line)
      (ad-activate 'js3-beginning-of-line)
      ;; (ad-activate 'js3-mode-create-imenu-index)
  
      (modify-syntax-entry ?_ "w" js3-mode-syntax-table)))
  
  ;; (set-default 'js3-indent-level 4)
  
  (setq js3-indent-level 4
        js3-cleanup-whitespace t
        js3-consistent-level-indent-inner-bracket t
        js3-enter-indents-newline t
        js3-highlight-level 3
        js3-mirror-mode nil
        js3-missing-semi-one-line-override t
        js3-rebind-eol-bol-keys t
        js3-highlight-external-variables t)
  
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; pretty print json
  (defun rk/pretty-json ()
    (interactive)
    (when (not (region-active-p))
      (error "need selection"))
    (let ((start (min (point) (mark)))
          (end (max (point) (mark))))
      (save-excursion
        (save-restriction
          (narrow-to-region start end)
          (goto-char (point-min))
          ;; line break after first "{"
          (if (re-search-forward "{\\([^\n]\\)" (point-max) t)
              (replace-match "{\n\\1" nil nil))
          ;; line break after every,
          (while (re-search-forward ",[\s-]*\\([^\n]\\)" (point-max) t)
            (replace-match ",\n\\1" nil nil))
          (goto-char (point-max))
          (if (re-search-backward "\\([^\n]\\)}" (point-min) t)
              (replace-match "\\1\n}" nil nil))
          (delete-trailing-whitespace (point-min) (point-max)))
        (indent-region start end))))
  
  (defun rk/remove-line-breaks ()
    (interactive)
    (when (not (region-active-p))
      (error "need selection"))
    (save-excursion
      (save-restriction
        (narrow-to-region (point) (mark))
        (goto-char (point-min))
        (while (re-search-forward "\n[\s-]*" (point-max) t)
          (replace-match "" nil nil)))))
  
  
  (defun rk/convert-js-var-block (start end)
    (interactive "r")
    (let ((new-end start))
      (save-excursion
        (save-restriction
          (narrow-to-region start end)
          (goto-char (point-min))
          ;; skip the first var
          (re-search-forward "\\s-*\\(var\\)\\s-+" (point-max) t)
          ;; replace all preceding vars
          (while (re-search-forward "\\(;\\)?\\(\\s-*\n\\s-*var\\s-+\\)" (point-max) t)
            (replace-match ",\n" nil nil))
          (setq new-end (point-max)))
        (indent-region start new-end))))
  
  (defun rk/toggle-js-whitespace-cleanup ()
    (interactive)
    (set-default 'js3-cleanup-whitespace (not js3-cleanup-whitespace))
    (message (concat "js3-cleanup-whitespace set to " (prin1-to-string js3-cleanup-whitespace))))
  
  (defun rk/js-make-pretty-with-uglify (js-source)
    (let ((temp-file (make-temp-file "ugly-json")))
      (unwind-protect
          (with-temp-buffer
            (insert js-source)
            (write-file temp-file)
            (let* ((cmd (concat "uglifyjs --beautify --indent 4 " temp-file))
                   (result (shell-command-to-string cmd)))
              (if (string-match "DEBUG: Error" result)
                  (message "Error running JS beautifier. Is source code valid?")
                (substring result 1 (- (length result) 2)))))
        (delete-file temp-file))))
  
  (defun rk/js-prettify-and-insert ()
    (interactive)
    ;; escape source in "(...);" so that JSON expressions go through
    (rk/with-active-region-or-line start end
      (let ((js-source (format "(%s);" (rk/current-region-or-line-string)))
            deactivate-mark)
        (kill-region start end)
        (push-mark nil t t)
        (insert (rk/js-make-pretty-with-uglify js-source)))))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; js3 ast helper
  (defun rk/js3-node-name-at-point ()
    ""
    (interactive)
    (message (js3-node-short-name (js3-node-at-point))))
  
  (defun rk/js3-get-func-def-info ()
    "example: returns '(\"$world\" \"addScript\" \"foo\"
    \"$world.addScript(fu|nction foo() {});\") from
    '$world.addScript(fu|nction () {});'"
    (let* ((current-node (js3-node-at-point))
           (func-node (if (= js3-FUNCTION (js3-node-type current-node))
                          current-node
                        (js3-node-get-enclosing-scope current-node)))
           (func-parent-node (js3-node-parent func-node))
            target-node)
       (when (and func-node func-parent-node (= js3-CALL (js3-node-type func-parent-node)))
         (setq target-node (js3-call-node-target func-parent-node))
         (mapcar 'js3-node-string (list
                                   (js3-prop-get-node-left target-node)
                                   (js3-prop-get-node-right target-node)
                                   (js3-function-node-name func-node)
                                   func-parent-node)))))
  
  ;; js3-node-abs-end
  (defun rk/js3-backward-up ()
    ""
    (interactive "")
    (let ((old-pos (point))
          (new-pos (js3-node-abs-pos (js3-node-parent (js3-node-at-point)))))
      (when (= old-pos new-pos)
          (setq new-pos (js3-node-abs-pos (js3-node-get-enclosing-scope (js3-node-at-point)))))
      ;; (if this-command-keys-shift-translated (message "fooo"))
      (goto-char new-pos)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;; (require 'jquery-doc)
  
  ;; adds ac-source-jquery to the ac-sources list
  ;; (remove-hook 'js3-mode-hook 'jquery-doc-setup)
  ;; (add-hook 'js3-mode-hook 'jquery-doc-setup)
  
  ;;; (remove-hook 'js3-mode-hook 'jquery-doc-setup)
  
#+END_SRC
* haskell
#+BEGIN_SRC elisp
  (dolist (hook '(haskell-mode-hook inferior-haskell-mode-hook))
    (add-hook hook 'turn-on-haskell-doc-mode)
    (setq haskell-doc-use-inf-haskell nil))
  
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
  ;; (add-hook 'haskell-mode-hook (lambda () (subword-mode +1)))
  ;; (add-hook 'haskell-mode-hook 'flymake-haskell-multi-load)
  
  (when (eval-when-compile (>= emacs-major-version 24))
    (require 'ghci-completion)
    (add-hook 'inferior-haskell-mode-hook 'turn-on-ghci-completion))
  
  (eval-after-load 'page-break-lines
    '(push 'haskell-mode page-break-lines-modes))
  
  (eval-after-load 'haskell
    '(progn (setq
             haskell-doc-use-inf-haskell nil t
             haskell-program-name "ghci \"+.\"")))
  
  ;; Make compilation-mode understand "at blah.hs:11:34-50" lines output by GHC
  (eval-after-load 'compile
    '(progn
       (let ((alias 'ghc-at-regexp))
         (add-to-list
          'compilation-error-regexp-alist-alist
          (list alias " at \\(.*\\.\\(?:l?[gh]hs\\|hi\\)\\):\\([0-9]+\\):\\([0-9]+\\)-[0-9]+$" 1 2 3 0 1))
         (add-to-list
          'compilation-error-regexp-alist alias))))
  
  (defun rk/haskell-send-buffer ()
    "eval current haskell buffer but don't switch to haskell
  interpreter"
    (interactive)
    (save-window-excursion (inferior-haskell-load-and-run ":main")))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
#+END_SRC

* key setup
** window related
#+BEGIN_SRC emacs-lisp
  (when *is-a-mac*
   (dolist (map `(,global-map ,minibuffer-local-map))
     (progn
       (print (prin1-to-string map))
       (define-key map (kbd "<s-home>") 'windmove-left)
       (define-key map (kbd "<s-end>") 'windmove-right)
       (define-key map (kbd "<s-prior>") 'windmove-up)
       (define-key map (kbd "<s-next>") 'windmove-down))))
  
  (global-set-key (kbd "C-x 4 t") 'transpose-buffers)
#+END_SRC

** for helm
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'rk/helm-buffers-and-files)

  (define-key helm-command-map (kbd "i") 'rk/helm-symbols)
  (define-key helm-command-map (kbd "b") 'rk/helm-buffers-and-files)
  (define-key helm-command-map (kbd "g") 'helm-do-grep)
#+END_SRC
** misc
#+BEGIN_SRC emacs-lisp
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; keys
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;; Activate occur easily inside isearch
  (define-key isearch-mode-map (kbd "C-o")
    (lambda () (interactive)
      (let ((case-fold-search isearch-case-fold-search)
            (current-line (line-number-at-pos)))
        (occur (if isearch-regexp isearch-string (regexp-quote isearch-string)))
        (isearch-exit)
        (with-buffer "*Occur*"
          (rk/forward-to-match (format "^\\s-*%s:" current-line))))))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; umlauts
  (global-unset-key (kbd "M-u"))
  (global-set-key (kbd "M-u a") (lambda () (interactive) (insert ?\ä)))
  (global-set-key (kbd "M-u o") (lambda () (interactive) (insert ?\õ)))
  (global-set-key (kbd "M-u u") (lambda () (interactive) (insert ?\ü)))
  (global-set-key (kbd "M-u A") (lambda () (interactive) (insert ?\Ä)))
  (global-set-key (kbd "M-u O") (lambda () (interactive) (insert ?\Ö)))
  (global-set-key (kbd "M-u U") (lambda () (interactive) (insert ?\Ü)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (require 'subword)
  (global-set-key [C-s-268632066] 'subword-backward) ; C-s-f
  (global-set-key [C-s-268632070] 'subword-forward) ; C-s-b
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  (defun rk/move-beginning-of-line (arg)
    "move either at `bol' or when already there then in front of
  the first non-whitespace char"
    (interactive "p")
    (let ((was-at-bol (bolp)))
      (move-beginning-of-line arg)
      (when was-at-bol
        (skip-chars-forward "\* \t"))))
  
  (global-set-key (kbd "C-a") 'rk/move-beginning-of-line)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  (global-set-key [remap goto-line] 'goto-line-with-feedback)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; moving text, really important
  (global-set-key [C-s-268632080] 'move-text-up) ; C-s-p
  (global-set-key [C-s-268632078] 'move-text-down) ; C-s-n
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; select line
  (defun rk/mark-line ()
    "activates the mark for the whole line. If line is already
  marked, shrinks the selection to the first non-whitespace char
  and end of the lines. Further command execution toggle between
  the states"
    (interactive)
    (let* ((start (if (region-active-p) (region-beginning) (point-at-bol)))
          (end (if (region-active-p) (region-end) (point-at-eol)))
          (line-marked-p (and (region-active-p) (= start (point-at-bol)) (= end (point-at-eol)))))
      (setq start (if line-marked-p
                      (save-excursion
                        ;; point in front of the first non-whitespace char
                        (beginning-of-line) (skip-chars-forward "\* \t")
                        (point))
                    ;; push the current pos first so we can easily jump back
                    (push-mark nil t) (point-at-bol)))
      (push-mark start t t)
      (goto-char end)))
  
  (global-set-key (kbd "s-l") 'rk/mark-line)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (global-set-key (kbd "C-c j") 'join-line)
  (global-set-key (kbd "C-c J") (lambda () (interactive) (join-line 1)))
  (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))
  
  (defun rk/newline-above ()
    ""
    (interactive)
    (move-beginning-of-line 1)
    (open-line 1))
  (defun rk/newline-below ()
    ""
    (interactive)
    (move-end-of-line nil)
    (newline-and-indent))
  (global-set-key (kbd "<S-return>") 'rk/newline-above)
  (global-set-key (kbd "<s-return>") 'rk/newline-below)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; duplicate line
  (defun duplicate-line (arg)
    "Duplicates the current line and inserts it above. If called
  with prefix `arg' inserts line below"
    (interactive "P")
    (rk/with-active-region-or-line start end
      (let (deactivate-mark
            (content (buffer-substring-no-properties start end)))
        (save-excursion
          (if arg (move-end-of-line 1) (move-beginning-of-line 1))
          (insert content)
          (newline)
          (unless arg (previous-line))))
      (rk/activate-region start end)))
  
  (global-set-key (kbd "C-c p") 'duplicate-line)
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; remove until line start
  (defun rk/delete-backward-line (region-start region-end)
    "If there is an active region, delete it. Otherwise remove everything
  from the beginning of the line to the current point.
  If point is at line start, remove line break."
    (interactive "r")
    (if (region-active-p)
        (delete-region region-start region-end)
      (let ((pos (point))
          (line-start-pos (save-excursion (forward-line 0) (point))))
      (delete-region
       (if (equal pos line-start-pos) (- pos 1) line-start-pos)
       (point)))))
  
  (global-set-key [s-backspace] 'rk/delete-backward-line)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  (global-set-key (kbd "s-w") 'kill-this-buffer)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (global-set-key [C-backspace] 'kill-word)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; escape as quit
  (defun rk/escape-key-action ()
    (interactive)
    (if (region-active-p)
        (progn
          (exchange-point-and-mark)
          (keyboard-quit))
      (keyboard-quit)))
  
  (global-set-key [escape] 'rk/escape-key-action)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; for quickcursor edits
  (global-set-key [C-f11] 'server-edit)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (fset 'open-eshell-minimized
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([24 50 s-next f6 115 115 115 115 115 115 115 115 115 115 115 115 115 113] 0 "%d")) arg)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (require 'iy-go-to-char)
  (eval-after-load "multiple-cursors"
    '(progn (add-to-list 'mc/cursor-specific-vars 'iy-go-to-char-start-pos)))
  (global-set-key (kbd "s-.") 'iy-go-to-char)
  (global-set-key (kbd "s-,") 'iy-go-up-to-char-backward)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; ace
  (require 'ace-jump-mode)
  (global-set-key (kbd "s-j") 'ace-jump-mode)
  (global-set-key (kbd "s-J") 'ace-jump-mode-pop-mark)
  (set-default 'ace-jump-mode-submode-list '(ace-jump-char-mode
                                             ace-jump-word-mode
                                             ace-jump-line-mode))
  
  (require 'cl)
  (setq ace-jump-mode-scope 'window
        ace-jump-mode-move-keys (loop for i from ?a to ?z collect i)
        ace-jump-mode-case-fold nil)
  
  (ace-jump-mode-enable-mark-sync)
  (define-key global-map (kbd "C-x SPC") 'ace-jump-mode-pop-mark)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; artist mode
  (eval-after-load "artist"
    '(progn
      (define-key artist-mode-map (kbd "s-o") 'artist-select-operation)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (global-set-key (kbd "M-/") 'hippie-expand)
  (global-set-key (kbd "s-?") 'ac-complete-with-helm)
  (global-set-key (kbd "M-SPC") 'ac-complete-with-helm)
  
  (set-default 'yas/trigger-key "s-\\")
  ;; (yas/initialize)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (defun rk/shell-mode-add-keys ()
    (local-set-key (kbd "s-p") (lambda () (interactive) (rk/shell-exec-expression 4)))
    (local-set-key (kbd "s-d") 'rk/shell-exec-expression))
  
  (add-hook 'sh-mode-hook 'rk/shell-mode-add-keys)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; init multiple cursors
  (require 'multiple-cursors)
  
  ;(define-key cua-global-keymap [(control return)] 'set-rectangular-region-anchor)
  (global-set-key [(control return)] 'set-rectangular-region-anchor)
  
  (global-set-key [C-s-268632067] 'mc/edit-lines)  ; C-s-c
  (global-set-key [C-s-268632069] 'mc/edit-ends-of-lines)  ; C-s-e
  (global-set-key [C-s-268632065] 'mc/edit-beginnings-of-lines)  ; C-s-a
  
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this-dwim)
  (global-set-key (kbd "C-c M-<") 'mc/mark-all-symbols-like-this-in-defun)
  (global-set-key (kbd "C-M-n") 'mc/mark-next-lines)
  (global-set-key (kbd "C-M-p") 'mc/mark-previous-lines)
  (global-set-key (kbd "<M-return>") 'mc/mark-more-like-this-extended) ; like the other two, but takes an argument (negative is previous)
  
  (define-key mc/keymap (kbd "<escape>") 'multiple-cursors-mode)
  (define-key mc/keymap (kbd "<return>") nil) ; <return> should work with mc
  
  (defun rk/eval-and-replace-last-sexp (value)
    "Evaluate the sexp at point and replace it with its value"
    (interactive (list (eval-last-sexp nil)))
    (kill-sexp -1)
    (insert (format "%S" value)))
  
  (global-set-key (kbd "C-x C-r") 'rk/eval-and-replace-last-sexp)
  
  (defun rk/eval-print-last-sexp (arg)
    (interactive "P")
    (if arg
        (pp-eval-last-sexp t)
        (eval-print-last-sexp)))
  
  (global-set-key (kbd "C-x C-p") 'rk/eval-print-last-sexp)
  
  (global-set-key (kbd "C-x p") 'mark-page)
  
  ;;; expand-region
  (require 'expand-region)
  (global-set-key (kbd "S-s-SPC") 'er/expand-region)
  (global-set-key [C-s-268632064] 'er/contract-region) ; C-s-SPC
#+END_SRC
** CMD keys
#+BEGIN_SRC emacs-lisp
    (eval-after-load "helm-config"
      '(progn
         (global-set-key (kbd "s-a") 'rk/helm-buffers-and-files)
  ;       (global-set-key (kbd "s-a") helm-find-filehelm-find-files)
         (global-set-key (kbd "M-x") 'helm-M-x)
         (global-set-key (kbd "s-k") 'rk/clear-buffer)
         (global-set-key (kbd "s-E") 'rk/helm-ac-completion)
         (global-set-key (kbd "s-S") 'helm-google-suggest)
         (global-set-key (kbd "s-R") 'helm-resume)
         (global-set-key (kbd "s-T") 'helm-find)
         (global-set-key (kbd "s-t") 'rk/helm-symbols)
         (global-set-key (kbd "s-g") (lambda (arg) (interactive "P") (rk/helm-symbols '(4))))
         (global-set-key (kbd "s-G") 'rk/helm-symbols)
         (global-set-key (kbd "s-/") 'comment-or-uncomment-region-or-line)
         (global-set-key (kbd "s-x") 'kill-region-or-line)
         (define-key dired-mode-map (kbd "s-o") (lambda (arg) (interactive "P") (dired-run-shell-command (format "open %s" (dired-file-name-at-point)))))))
#+END_SRC
** CMD-Shift-L map
#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "s-L"))
  (if (boundp '*textmate-mode-map*)
      (define-key *textmate-mode-map* (kbd "s-L") nil))

  (defvar l-map (make-keymap)
    "Keymap for local bindings and functions, prefixed by (s-L)")
  (define-key global-map (kbd "s-L") 'L-prefix)
  (define-key global-map (kbd "C-c l") 'L-prefix)
  (fset 'L-prefix l-map)

  (defmacro add-to-l-map (&rest mappings)
    `(loop for (keys func)
           on ',mappings
           by 'cddr
           do (define-key l-map keys func)))

  (add-to-l-map
   "bb"   helm-buffers+
   "bc"   clone-buffer
   "bdel" delete-this-file
   "bdiff" diff-buffer-with-file
   "bi"   clone-indirect-buffer
   "br"   rename-this-file-and-buffer
   "caa"  align
   "car"  align-regexp
   "clear" rk/clear-buffer
   "date" rk/insert-date
   "dup"  duplicate-line
   "dp"   rk/copy-full-path-to-kill-ring
   "dP"   rk/copy-buffer-name-to-kill-ring
   "ds"   dictionary-search
   "dm"   dictionary-popup-matching-words
   "eb"   ediff-buffers
   "ed"   ediff-directories
   "el"   ediff-regions-linewise
   "ew"   ediff-regions-wordwise
   "ef"   ediff-files
   "ep"   ediff-patch-buffer
   "em"   ediff-merge-buffers
   "ercf" rk/erc-make-frame
   "ercw" rk/erc-setup-windows
   "fn"   find-name-dired
   "fs"   rk/fringe-shrink
   "fw"   rk/fringe-widen
   "g"    helm-do-grep
   "G"    rgrep
   "h$"   rk/jQuery-doc
   "ha"   helm-c-apropos
   "hb"   helm-browse-code
   "hc"   describe-key-briefly
   "hd"   apropos-documentation
   "hf"   describe-function
   "hh"   help-for-help
   "hi"   helm-info-emacs
   "hk"   helm-show-kill-ring
   "hl"   helm-locate
   "hL"   view-lossage
   "hm"   helm-man-woman
   "hp"   finder-by-keyword
   "hq"   help-quit
   "hr"   helm-register
   "hs"   describe-syntax
   "hu"   helm-ucs
   "hv"   describe-variable
   "hw"   where-is
   "hy"   helm-show-kill-ring
   "h%"   helm-regexp
   "ii"   rk/images-find-image-strings-and-replace-with-image
   "ir"   rk/images-replace-inserted-images-with-image-strings
   "iy"   rk/images-paste-and-insert-from-clipboard
   "is"   rk/images-read-rescale-factor
   "jsc"  rk/slime-js-set-doit-context
   "json" rk/pretty-json
   "jsp"  rk/js-prettify-and-insert
   "jsl"  rk/slime-js-overlay-make-or-update
   "jsL"  rk/slime-js-overlay-remove-overlay-at-point
   "jsv"  rk/convert-js-var-block
   "jssr" slime-js-sticky-select-remote
   "jssw" rk/toggle-js-whitespace-cleanup
   "jsstart" rk/slime-js-start
   "lf"   flush-lines
   "lF"   keep-lines
   "lg"   goto-line
   "lke"  rk/lively-eval-add-method-to-class
   "lkfo" rk/find-same-file-in-ww-or-core-other-window
   "lkm"  rk/ww-mirror-commit-from-merge-spec
   "lks"  rk/mirror-lively-to-my-server
   "lnb"  rk/remove-line-breaks
   "lt"   toggle-truncate-lines
   "lu"   lively-update
   "lv"   lively
   "lV"   lively-stop
   "L"    goto-line
   "ma"   artist-mode
   "mdiff" diff-mode
   "mmd"  markdown-mode
   "mfm"  flymake-mode
   "msw"  subword-mode
   "mfw"  follow-mode
   "mfs"  flyspell-mode
   "morg" org-mode
   "mw"   whitespace-mode
   "name" rk/insert-name-email
   "occ"  occur
   "op"   org-insert-property-drawer
   "ot"   org-show-todo-tree
   "or"   remember
   "q"    query-replace
   "Q"    query-replace-regexp
   "rw"   resize-window
   "so"   open-eshell-minimized
   "ss"   eshell
   "sx"   rk/shell-exec-expression
   "sudo" sudo-edit
   "t1"   rk/transpose-region-remember-region-1
   "t2"   rk/transpose-region-active-with-region-1
   "term" rk/visit-term-buffer
   "ui"   ucs-insert
   "U"    browse-url-at-point
   "v="   vc-diff
   "va"   vc-annotate
   "vd"   vc-dir
   "vD"   vc-delete-file
   "vF"   vc-pull
   "vgl"  gist-list
   "vgf"  gist-fetch
   "vgp"  gist-region-or-buffer
   "vl"   vc-print-log
   "vu"   vc-revert
   "vv"   vc-next-action
   "vm"   magit-status-somedir
   "work" tomatinho
   "ws"   rk/copy-stringified
   "wm"   whitespace-mode
   "wt"   delete-trailing-whitespace
   "xx"   execute-extended-command
   "xb"   eval-buffer
   "xe"   eval-last-sexp
   "xp"   eval-print-last-sexp
   "xr"   eval-region
   "xs"   slime-eval-buffer
   "ye"   yas/exit-all-snippets
   "yc"   helm-c-yas-complete
   "!"    shell-command
   "^"    join-line
   "//"   comment-or-uncomment-region-or-line
   "/b"   rk/comment-box
   "/d"   rk/divider)
#+END_SRC
** haskell
#+BEGIN_SRC elisp
  (eval-after-load 'haskell-mode
    '(progn
       (define-key haskell-mode-map (kbd "C-c h") 'hoogle)
       (define-key haskell-mode-map (kbd "C-o") 'open-line)
       (define-key haskell-mode-map (kbd "C-c C-l") 'rk/haskell-send-buffer)
       (setq
        haskell-doc-use-inf-haskell t
        haskell-program-name "ghci \"+.\""
        haskell-indent-offset 2)))
  
#+END_SRC

** javascript
*** js3
#+BEGIN_SRC elisp
  (defun rk/setup-js3-keys ()
    ""
    (define-key js3-mode-map (kbd "C-M-u") 'rk/js3-backward-up))
  
  (eval-after-load "js3"
    '(rk/setup-js3-keys))
#+END_SRC

*** slime-js
#+BEGIN_SRC elisp :tangle no
  ;; -=-=-=-=-
  ;; css setup
  ;; -=-=-=-=-
  ;; (defun rk/slime-js-css-keys ()
  ;;   (define-key css-mode-map (kbd "M-C-x") 'slime-js-refresh-css)
  ;;   (define-key css-mode-map (kbd "M-SPC") 'slime-js-embed-css)
  ;;   (define-key css-mode-map (kbd "s-d") 'slime-js-embed-css))
  
  ;; -=-=-=-=-
  ;; js setup
  ;; -=-=-=-=-
  ;; (defun add-slime-js-keys ()
  ;;   (condition-case ex
  ;;       (progn
  ;;         (local-set-key (kbd "C-x C-e") 'rk/slime-js-send-region-or-last-sexp)
  ;;         (local-set-key (kbd "s-d") (lambda (p1 p2) (interactive "r")
  ;;                                      (let ((*rk/slime-js-print-result-p* nil))
  ;;                                        (rk/slime-js-send-region-or-last-sexp p1 p2))))
  ;;         (local-set-key (kbd "s-p") (lambda (p1 p2) (interactive "r")
  ;;                                      (let ((*rk/slime-js-print-result-p* t))
  ;;                                        (rk/slime-js-send-region-or-last-sexp p1 p2))))
  ;;         (local-set-key (kbd "s-i") 'rk/slime-js-send-and-inspect)
  ;;         (local-set-key (kbd "s-U") 'rk/slime-js-overlay-make-or-update)
  ;;         (local-set-key (kbd "s-S") 'rk/slime-js-overlay-remove-overlay-at-point)
  ;;         (local-set-key (kbd "s-A") (lambda () (interactive)
  ;;                                      (slime-eval-buffer)
  ;;                                      (run-with-timer 0.3 nil 'rk/slime-js-overlay-eval-all)))
  ;;         (local-set-key (kbd "M-SPC") 'rk/slime-js-send-defun)
  ;;         (local-set-key (kbd "C-c b") (lambda () (interactive)
  ;;                                        (let ((*rk/slime-js-print-result-p* nil))
  ;;                                          (rk/slime-js-send-buffer)))))
  ;;     ('error (message (format "Caught exception: [%s]" ex)))))
  
  
  (define-key js3-mode-map (kbd "C-x C-e") 'rk/slime-js-send-region-or-last-sexp)
  (define-key js3-mode-map (kbd "s-d") (lambda (p1 p2) (interactive "r")
                               (let ((*rk/slime-js-print-result-p* nil))
                                 (rk/slime-js-send-region-or-last-sexp p1 p2))))
  (define-key js3-mode-map (kbd "s-p") (lambda (p1 p2) (interactive "r")
                               (let ((*rk/slime-js-print-result-p* t))
                                 (rk/slime-js-send-region-or-last-sexp p1 p2))))
  (define-key js3-mode-map (kbd "s-i") 'rk/slime-js-send-and-inspect)
  ;; (define-key js3-mode-map (kbd "s-U") 'rk/slime-js-overlay-make-or-update)
  ;; (define-key js3-mode-map (kbd "s-S") 'rk/slime-js-overlay-remove-overlay-at-point)
  ;; (define-key js3-mode-map (kbd "s-A") (lambda () (interactive)
  ;;                              (slime-eval-buffer)
  ;;                              (run-with-timer 0.3 nil 'rk/slime-js-overlay-eval-all)))
  (define-key js3-mode-map (kbd "M-SPC") 'rk/slime-js-send-defun)
  (define-key js3-mode-map (kbd "C-c b") (lambda () (interactive)
                                 (let ((*rk/slime-js-print-result-p* nil))
                                   (rk/slime-js-send-buffer))))
  
  ;; (eval-after-load "init-javascript"
  ;;   '(progn
  ;;      (add-hook 'css-mode-hook 'rk/slime-js-css-keys)
  ;;      (add-mode-hook-for-js 'add-slime-js-keys t)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; javascript stuff
  ;; (defun rk/add-js3-keys ()
  ;;   (local-set-key (kbd "C-c i") 'rk/pretty-json)
  ;;   (local-set-key (kbd "s-D") 'js3-mark-defun)
  ;;   (local-set-key (kbd "M-D") 'rk/lively-try-eval-def)
  ;;   (local-set-key (kbd "s-B") 'rk/lively-browse-object-scripts)
  ;;   ;; pressing shift with C-a/e should automatically enable transient mark mode
  ;;   ;; but in recent js3 version this does not work anymore
  ;;   (local-set-key (kbd "C-S-e") (lambda () (interactive)
  ;;                                  (unless (region-active-p)
  ;;                                    (call-interactively 'set-mark-command))
  ;;                                  (call-interactively 'js3-end-of-line)))
  ;;   (local-set-key (kbd "C-S-a") (lambda () (interactive)
  ;;                                  (unless (region-active-p)
  ;;                                    (call-interactively 'set-mark-command))
  ;;                                  (call-interactively 'js3-beginning-of-line)))
  ;;   (global-set-key (kbd "<end>") 'js3-end-of-line)
  ;;   (global-set-key (kbd "<home>") 'js3-beginning-of-line)
  ;;   (local-set-key (kbd "C-c C-p") 'rk/js3-node-name-at-point)
  ;;   (local-set-key (kbd "C-M-u") 'rk/js3-backward-up))
  
  ;; (eval-after-load 'js3-mode
  ;;   `(progn
  ;;      (add-hook 'js3-mode-hook 'rk/add-js3-keys)))
#+END_SRC

* mode mappings
#+BEGIN_SRC elisp
    ;; -*-no-byte-compile: t; -*-

    ;;; clojure
    (autoload 'clojure-mode "clojure-mode")
    (add-to-list 'auto-mode-alist '("\\.clj$" . clojure-mode))

    ;;; git
    (autoload 'rebase-mode "rebase-mode")
    (add-to-list 'auto-mode-alist '("git-rebase-todo" . rebase-mode))
    (add-to-list 'auto-mode-alist '("\\(?:\\.gitconfig\\|\\.gitmodules\\|config\\)$" . conf-mode))

    ;;; js
    ;; Need to first remove from list if present, since elpa adds entries too, which
    ;; may be in an arbitrary order
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js3-mode))
    (add-to-list 'interpreter-mode-alist '("node" . js3-mode))

  ;  (autoload 'js3-mode "js3-mode")
  ;  (eval-when-compile (require 'cl))

  ;  (add-to-list 'interpreter-mode-alist '("node" . js3-mode))
  ;  (add-to-list 'interpreter-mode-alist '("shjs" . js3-mode))

    ;;; elisp
    (add-to-list 'auto-mode-alist '("\\.emacs-project$" . emacs-lisp-mode))

    ;;; markdown
    (autoload 'markdown-mode "markdown-mode" "Mode for editing Markdown documents" t)
    (setq auto-mode-alist
          (cons '("\\.\\(md\\|markdown\\)$" . markdown-mode) auto-mode-alist))

    ;;; org
    (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))

    ;;; shell
    (autoload 'shell-script-mode "shell-script-mode")
    (add-to-list 'auto-mode-alist '("\\.[a-z]?sh$" . shell-script-mode))

    ;;; diff
    (add-to-list 'magic-mode-alist '("\$ git.*diff" . diff-mode))

    ;;; applescript
    (autoload 'applescript-mode "applescript-mode"
      "Major mode for editing AppleScript source." t)
    (add-to-list 'auto-mode-alist '("\\.applescript$" . applescript-mode))

    ;;; octave
    (autoload 'octave-mode "octave-mod" nil t)
    (add-to-list 'auto-mode-alist '("\\.m$" . octave-mode))

    (autoload 'arduino-mode "arduino-mode" "Major mode for editing Arduino code." t)
    (add-to-list 'auto-mode-alist '("\\.\\(pde\\|ino\\)$" . arduino-mode))

    (autoload 'haskell-mode "haskell-mode" "Major mode for editing Haskell code." t)
    (add-to-list 'auto-mode-alist '("\\.ghci$" . 'haskell-mode))

  
    (add-to-list 'auto-mode-alist '("Dockerfile" . conf-mode))
#+END_SRC
* mode-line
#+BEGIN_SRC elisp
  ;; Diminish modeline clutter
  (require 'diminish)
  (eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
  (eval-after-load "auto-complete" '(diminish 'auto-complete-mode))
  (eval-after-load "helm" '(diminish 'helm-mode))
  (eval-after-load "eldoc" '(diminish 'eldoc-mode))
  
  
  (defmacro rename-modeline (package-name mode new-name)
    `(eval-after-load ,package-name
       '(defadvice ,mode (after rename-modeline activate)
          (setq mode-name ,new-name))))
  
  (rename-modeline "js2-mode" js2-mode "js2")
  (rename-modeline "js3" js3-mode "js3")
  (rename-modeline "clojure-mode" clojure-mode "clj")
  (rename-modeline "lisp-mode" emacs-lisp-mode "elisp")
#+END_SRC

* theming / colors
** theme
#+BEGIN_SRC elisp
  (custom-set-faces
   '(show-paren-match
     ((t(:weight bold :slant normal :underline nil :inverse-video t :foreground "#aadddd" :background "#292929")))))
  
  (load-theme 'noctilux t)
 #+END_SRC
** font size
#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun font-name-replace-size (font-name new-size)
  (let ((parts (split-string font-name "-")))
    (setcar (nthcdr 7 parts) (format "%d" new-size))
    (mapconcat 'identity parts "-")))

(defun increment-default-font-height (delta)
  "Adjust the default font height by DELTA on every frame.
The pixel size of the frame is kept (approximately) the same.
DELTA should be a multiple of 10, in the units used by the
:height face attribute."
  (let* ((new-height (+ (face-attribute 'default :height) delta))
         (new-point-height (/ new-height 10)))
    (dolist (f (frame-list))
      (with-selected-frame f
        ;; Latest 'set-frame-font supports a "frames" arg, but
        ;; we cater to Emacs 23 by looping instead.
        (set-frame-font (font-name-replace-size (face-font 'default)
                                                new-point-height)
                        t)))
    (set-face-attribute 'default nil :height new-height)
    (message "default font size is now %d" new-point-height)))

(defun increase-default-font-height ()
  (interactive)
  (increment-default-font-height 10))

(defun decrease-default-font-height ()
  (interactive)
  (increment-default-font-height -10))

(global-set-key (kbd "C-M-=") 'increase-default-font-height)
(global-set-key (kbd "C-M--") 'decrease-default-font-height)
#+END_SRC

* server
#+BEGIN_SRC elisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC
* custom
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat dotfiles-dir "custom.el"))
  (load custom-file)
#+END_SRC
