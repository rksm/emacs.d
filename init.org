* requirements / packages

** load path, etc.
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "~/.emacs.d"))
#+END_SRC

** elpa
*package.el* proved to be sufficient for getting recent packages/projects from
ELPA/marmalade repos.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
  (add-to-list 'package-archives '("tromey" . "http://tromey.com/elpa/") t)
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (package-initialize)
  (package-refresh-contents)
  
  ;; (makunbound 'my-packages)
  (defvar my-packages
    '(iy-go-to-char
      ace-jump-mode
      multiple-cursors
      expand-region
      move-text
      auto-complete
      helm
      wgrep
      magit
      ;; weby stuff
      markdown-mode
      ;; js
      js3-mode
      ;; lispy things
      rainbow-delimiters
      paredit
      clojure-mode clojure-test-mode nrepl ac-nrepl nrepl-ritz
      ;; erc
      ;; znc ;; bouncer
      ))
  
  (dolist (p my-packages)
    (when (not (package-installed-p p))
      (package-install p)))
#+END_SRC
** site-lisp
#+BEGIN_SRC elisp
  (add-to-list 'load-path (concat (expand-file-name "~/.emacs.d/site-lisp/") "fringemark"))
#+END_SRC
* generic settings
** system-related
#+BEGIN_SRC emacs-lisp
(setq *spell-check-support-enabled* t)
(setq *is-a-mac* (eq system-type 'darwin))
(setq *is-carbon-emacs* (and *is-a-mac* (eq window-system 'mac)))
(setq *is-cocoa-emacs* (and *is-a-mac* (eq window-system 'ns)))
#+END_SRC

** emacs interaction
#+BEGIN_SRC emacs-lisp
   (fset 'yes-or-no-p 'y-or-n-p)
   (column-number-mode 1)
   (setq-default blink-cursor-delay 0
                 blink-cursor-interval 0.8
                 mouse-highlight nil
                 bookmark-default-file "~/.emacs.d/.bookmarks.el"
                 buffers-menu-max-size 30
                 case-fold-search t
                 compilation-scroll-output t
                 ediff-split-window-function 'split-window-horizontally
                 ediff-window-setup-function 'ediff-setup-windows-plain
                 grep-highlight-matches t
                 grep-scroll-output nil
                 indent-tabs-mode nil
                 tab-width 4
                 line-spacing 0.2
                 set-mark-command-repeat-pop t
                 show-trailing-whitespace t
                 tooltip-delay 1.5
                 truncate-lines nil
                 truncate-partial-width-windows nil
                 visible-bell t
                 fill-column 80
                 ;; backups
                 make-backup-files t
                 backup-directory-alist '(("." . "~/.emacs.d/backups"))
                 kept-new-versions 6
                 kept-old-versions 2
                 version-control t
                 ;; autosave
                 auto-save-file-name-transforms `(("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" ,temporary-file-directory t)
                                                  (".*" "~/.emacs.d/backups" t))
                 ;; lock files
                 create-lockfiles nil)
  
   (transient-mark-mode t)
   (delete-selection-mode t)
   ;; (cua-selection-mode t)
  
  (show-paren-mode 1)
  (electric-pair-mode 1)
  
   ;; remember cursor pos
   (setq save-place t)
   (require 'saveplace)
   (setq save-place-file "~/.emacs.d/saved-places")
#+END_SRC

* useful functions
** strings and list processing
#+BEGIN_SRC emacs-lisp
(defun rk/string-join (list &optional separator item-converter)
  (mapconcat (or item-converter 'identity) list (or separator "\n")))

(defun rk/filter (condp lst)
  (delq nil (mapcar (lambda (x) (and (funcall condp x) x)) lst)))

(defun rk/string-match (string regexp index-or-list)
  "match string with regexp and return those matches defined by `index-or-list'"
  (save-match-data
    (let ((success (string-match regexp string)))
     (when success
       (if (numberp index-or-list)
           (match-string-no-properties index-or-list string)
         (mapcar (lambda (n) (match-string-no-properties n string)) index-or-list))))))
#+END_SRC
** buffer related
#+BEGIN_SRC elisp
  (require 'fringemark)
  (defun rk/fringe-shrink ()
    "for focusing on one buffer"
    (interactive)
    (let* ((target-frame-width 800)
          (required-fringe-width (- (frame-pixel-width) target-frame-width)))
      (unless (< (frame-pixel-width) target-frame-width)
        (set-fringe-style (floor required-fringe-width 2)))))
  
  (defun rk/fringe-widen ()
    (interactive)
    (set-fringe-style nil))
#+END_SRC
** comments
#+BEGIN_SRC elisp
  ;;; allow-line-as-region-for-function adds an "-or-line" version of
  ;;; the given comment function which (un)comments the current line is
  ;;; the mark is not active.  This code comes from Aquamac's osxkeys.el
  ;;; and is licensed under the GPL
  
  (defmacro allow-line-as-region-for-function (orig-function)
  `(defun ,(intern (concat (symbol-name orig-function) "-or-line"))
     ()
     ,(format "Like `%s', but acts on the current line if mark is not active."
              orig-function)
     (interactive)
     (if mark-active
         (call-interactively (function ,orig-function))
       (save-excursion
         ;; define a region (temporarily) -- so any C-u prefixes etc. are preserved.
         (beginning-of-line)
         (set-mark (point))
         (end-of-line)
         (call-interactively (function ,orig-function))))))
  
  (defun rk/define-comment-line ()
    "Add or-line (un)comment function if not already defined"
    (unless (fboundp 'comment-or-uncomment-region-or-line)
      (allow-line-as-region-for-function comment-or-uncomment-region)))
  
  (rk/define-comment-line)
  
#+END_SRC
* org-mode

#+BEGIN_SRC emacs-lisp
  (setq org-log-done t
        org-completion-use-ido nil
        org-edit-timestamp-down-means-later t
        org-agenda-start-on-weekday t
        org-agenda-span 14
        org-agenda-include-diary t
        org-agenda-window-setup 'current-window
        org-fast-tag-selection-single-key nil
        org-export-kill-product-buffer-when-displayed t
        org-tags-column 80
        org-src-tab-acts-natively t
        org-confirm-babel-evaluate nil
        org-src-window-setup 'current-window)

  ;; active Babel languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t)
     (emacs-lisp . t)
     (js . t)))

  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)

  ;; (eval-after-load 'org
  ;;   '(progn
  ;;      (org-defkey org-mode-map (kbd "<S-return>") 'rk/open-line-above)))
#+END_SRC

* shell scripting
** scripts
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
** emacs & shell
#+BEGIN_SRC emacs-lisp
  ;;; getting the system shell vars I care about into emacs
  (defmacro rk/set-env-from-system-shell (&rest var-names)
    "query var-names via `env' command from system shell and
  generate a bunch of `setenv' statements from it"
    `(progn
       ,@(let* ((cmd (format "$SHELL --login -i -c 'env | egrep \"^(%s)=\"'"
                             (rk/string-join var-names "|")))
                (shell-out (shell-command-to-string cmd))
                (lines (split-string shell-out "[\n]+"))
                (vars-and-vals (rk/filter (lambda (pair) (and pair (car pair) (cadr pair)))
                   (mapcar
                                (lambda (line) (rk/string-match line "\\([^=]+\\)=\\(.*\\)" '(1 2)))
                                lines))))
           (mapcar (lambda (var-value) `(setenv ,@var-value)) vars-and-vals))))
  
  (when (and *is-a-mac* window-system)
    (rk/set-env-from-system-shell
     "PATH" "MANPATH"
     "CPATH" "PKG_CONFIG_PATH" "C_INCLUDE_PATH" "CPLUS_INCLUDE_PATH" "PYTHONPATH"
     "ZSH_PROFILE"
     "PLAYERPATH" "STAGEPATH" "ROS_OS_OVERRIDE"
     "ARDUINO_DIR" "ARDMK_DIR"
     "NOTES" "LIVELY" "WEBWERKSTATT"))
  
  (setq exec-path (split-string (getenv "PATH") path-separator))
  (setenv "PAGER" "/bin/cat")
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; eshell
  (setq eshell-buffer-shorthand t)
  
  ;;; tramp
  (setq tramp-default-user-alist '(("\\`smb\\'" nil nil)
                                   ("\\`\\(?:fcp\\|krlogin\\|r\\(?:cp\\|emcp\\|sh\\)\\|telnet\\)\\'" nil "robert")
                                   ("\\`\\(?:ksu\\|su\\(?:do\\)?\\)\\'" nil "root")
                                   ("\\`\\(?:socks\\|tunnel\\)\\'" nil "robert")
                                   ("\\`synce\\'" nil nil)
                                   ("\\`ssh\\'" "nil" "robert")))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (defun rk/shell-exec-and-replace-lines ()
    (interactive)
    (rk/do-for-each-line-in-region 'shell-command-to-string))
  
  (defun rk/shell-exec-expression (&optional print-it)
    (interactive "p")
    (let* ((start (if (region-active-p) (mark) (line-beginning-position)))
           (end (if (region-active-p) (point) (line-end-position)))
           (lines (split-string (buffer-substring-no-properties start end) "[\n]+"))
           (command (rk/string-join lines " \\\n"))
           (result (shell-command-to-string command)))
      (if (= 4 print-it)
          (let (deactivate-mark)
            (push-mark nil nil t)
            (insert result))
        (slime-flash-region start end 0.7))))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; eshell
  
  (defun eshell/edit (file)
    (find-file file))
  
  
  (defun eshell/ll (&rest ARGS)
    (eshell/ls (cons "-l" ARGS)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (custom-set-variables
   '(Man-notify-method (quote pushy)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; doesn't really belong here
  (set-default 'comint-scroll-to-bottom-on-input t)
  (set-default 'comint-scroll-to-bottom-on-output t)
  (set-default 'comint-move-point-for-output t)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (defun rk/visit-term-buffer ()
    "Create or visit a terminal buffer."
    (interactive)
    (if (not (get-buffer "*ansi-term*"))
        (progn
          (ansi-term (getenv "SHELL")))
      (switch-to-buffer "*ansi-term*")))
  
  (add-hook 'term-mode-hook (lambda () (setq show-trailing-whitespace nil)))
  ;; (add-hook 'term-mode-hook (lambda () (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix)))
  ;; (remove-hook 'term-mode-hook (car term-mode-hook))
  
#+END_SRC
* misc
** windows
#+BEGIN_SRC emacs-lisp
(winner-mode 1) ;; C-c <left>, C-c <right> for back/forth window layout

;;; resize windows interactively, from http://www.emacswiki.org/emacs/WindowResize
(defun resize-window (&optional arg)    ; Hirose Yuuji and Bob Wiener
  "*Resize window interactively."
  (interactive "p")
  (if (one-window-p) (error "Cannot resize sole window"))
  (or arg (setq arg 10))
  (let (c)
    (catch 'done
      (while t
    (message
     "h=heighten, s=shrink, w=widen, n=narrow (by %d);  1-9=unit, q=quit"
     arg)
    (setq c (read-char))
    (condition-case ()
        (cond
         ((= c ?h) (enlarge-window arg))
         ((= c ?s) (shrink-window arg))
         ((= c ?w) (enlarge-window-horizontally arg))
         ((= c ?n) (shrink-window-horizontally arg))
         ((= c ?\^G) (keyboard-quit))
         ((= c ?q) (throw 'done t))
         ((and (> c ?0) (<= c ?9)) (setq arg (- c ?0)))
         (t (beep)))
      (error (beep)))))
    (message "Done.")))

(global-set-key (kbd "<f6>") 'resize-window)
;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

(add-to-list 'same-window-regexps ".*")

;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

(eval-after-load "compile"
'(defun compilation-goto-locus (msg mk end-mk)
  "Jump to an error corresponding to MSG at MK.
All arguments are markers.  If END-MK is non-nil, mark is set there
and overlay is highlighted between MK and END-MK."
  ;; Show compilation buffer in other window, scrolled to this error.
  (let* ((from-compilation-buffer (eq (window-buffer (selected-window))
                  (marker-buffer msg)))
     ;; Use an existing window if it is in a visible frame.
     (pre-existing (get-buffer-window (marker-buffer msg) 0))
     (w (if (and from-compilation-buffer pre-existing)
        ;; Calling display-buffer here may end up (partly) hiding
        ;; the error location if the two buffers are in two
        ;; different frames.  So don't do it if it's not necessary.
        pre-existing
      (let ((display-buffer-reuse-frames t)
        (pop-up-windows t))
        ;; Pop up a window.
        (display-buffer (marker-buffer msg)))))
     (highlight-regexp (with-current-buffer (marker-buffer msg)
             ;; also do this while we change buffer
             (compilation-set-window w msg)
             compilation-highlight-regexp)))
;; Ideally, the window-size should be passed to `display-buffer' (via
;; something like special-display-buffer) so it's only used when
;; creating a new window.
(unless pre-existing (compilation-set-window-height w))

(switch-to-buffer (marker-buffer mk))

    ;; was
;; (if from-compilation-buffer
;;     ;; If the compilation buffer window was selected,
;;     ;; keep the compilation buffer in this window;
;;     ;; display the source in another window.
;;     (let ((pop-up-windows t))
;;       (pop-to-buffer (marker-buffer mk) 'other-window))
;;   (if (window-dedicated-p (selected-window))
;;       (pop-to-buffer (marker-buffer mk))
;;     (switch-to-buffer (marker-buffer mk))))
;; If narrowing gets in the way of going to the right place, widen.
(unless (eq (goto-char mk) (point))
  (widen)
  (goto-char mk))
(if end-mk
    (push-mark end-mk t)
  (if mark-active (setq mark-active)))
;; If hideshow got in the way of
;; seeing the right place, open permanently.
(dolist (ov (overlays-at (point)))
  (when (eq 'hs (overlay-get ov 'invisible))
    (delete-overlay ov)
    (goto-char mk)))

(when highlight-regexp
  (if (timerp next-error-highlight-timer)
      (cancel-timer next-error-highlight-timer))
  (unless compilation-highlight-overlay
    (setq compilation-highlight-overlay
      (make-overlay (point-min) (point-min)))
    (overlay-put compilation-highlight-overlay 'face 'next-error))
  (with-current-buffer (marker-buffer mk)
    (save-excursion
      (if end-mk (goto-char end-mk) (end-of-line))
      (let ((end (point)))
    (if mk (goto-char mk) (beginning-of-line))
    (if (and (stringp highlight-regexp)
         (re-search-forward highlight-regexp end t))
        (progn
          (goto-char (match-beginning 0))
          (move-overlay compilation-highlight-overlay
                (match-beginning 0) (match-end 0)
                (current-buffer)))
      (move-overlay compilation-highlight-overlay
            (point) end (current-buffer)))
    (if (or (eq next-error-highlight t)
        (numberp next-error-highlight))
        ;; We want highlighting: delete overlay on next input.
        (add-hook 'pre-command-hook
              'compilation-goto-locus-delete-o)
      ;; We don't want highlighting: delete overlay now.
      (delete-overlay compilation-highlight-overlay))
    ;; We want highlighting for a limited time:
    ;; set up a timer to delete it.
    (when (numberp next-error-highlight)
      (setq next-error-highlight-timer
        (run-at-time next-error-highlight nil
                 'compilation-goto-locus-delete-o)))))))
(when (and (eq next-error-highlight 'fringe-arrow))
  ;; We want a fringe arrow (instead of highlighting).
  (setq next-error-overlay-arrow-position
    (copy-marker (line-beginning-position)))))))
#+END_SRC

** frames
Suppress GUI features
#+BEGIN_SRC emacs-lisp
(setq use-file-dialog nil)
(setq use-dialog-box nil)
(setq inhibit-startup-screen t)
(setq inhibit-startup-echo-area-message t)
(when (fboundp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (fboundp 'set-scroll-bar-mode)
  (set-scroll-bar-mode nil))
#+END_SRC
*** Mac OS fullscreen
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'ns-toggle-fullscreen)
    (defadvice ns-toggle-fullscreen (after mark-full-screen activate)
      (set-frame-parameter nil
                           'is-full-screen
                           (not (frame-parameter nil 'is-full-screen)))))

  (when (and *is-cocoa-emacs* (not (fboundp 'ns-toggle-fullscreen)))
    (defun ns-toggle-fullscreen ()
      "Toggle full screen"
      (interactive)
      ;; (debug)
      (set-frame-parameter
       nil 'fullscreen
       (when (not (frame-parameter nil 'fullscreen)) 'fullscreen))))

  (when (fboundp 'ns-toggle-fullscreen)
    ;; Command-Option-f to toggle fullscreen mode
    (global-set-key (kbd "M-s-ƒ") 'ns-toggle-fullscreen))
#+END_SRC
* project support
** find stuff
#+BEGIN_SRC emacs-lisp
  ;;; adapted from textmate.el
  
  ;;;;;;;;;;;;
  ;; helper ;;
  ;;;;;;;;;;;;
  
  ;; http://snipplr.com/view/18683/stringreplace/
  (defun rk/string-replace (this withthat in)
    "replace THIS with WITHTHAT' in the string IN"
    (with-temp-buffer
      (insert in)
      (goto-char (point-min))
      (while (search-forward this nil t)
        (replace-match withthat nil t))
      (buffer-substring (point-min) (point-max))))
  
  ;;;;;;;;;;;;;;;;;;
  ;; project root ;;
  ;;;;;;;;;;;;;;;;;;
  (defvar *rk/project-root* nil
    "Used internally to cache the project root.")
  
  (defvar *rk/project-roots* '(".git" ".hg" "Rakefile" "Makefile" "README" "README.md" "build.xml" ".emacs-project")
  "The presence of any file/directory in this list indicates a project root.")
  
  (defun rk/find-project-root (&optional root)
    "Determines the current project root by recursively searching for an indicator."
    (when (null root) (setq root default-directory))
    (cond
     ((rk/root-matches root *rk/project-roots*)
      (expand-file-name root))
     ((equal (expand-file-name root) "/") nil)
     (t (rk/find-project-root (concat (file-name-as-directory root) "..")))))
  
  (defun rk/project-root ()
    "Returns the current project root."
    (when (or
           (null *rk/project-root*)
           (not (string-match *rk/project-root* default-directory)))
      (let ((root (rk/find-project-root)))
        (if root
            (setq *rk/project-root* (expand-file-name (concat root "/")))
          (setq *rk/project-root* nil))))
    ,*rk/project-root*)
  
  ;;; -=-=-=-=-=-=-=-=-=-
  
  (defun rk/root-match(root names)
    (member (car names) (directory-files root)))
  
  (defun rk/root-matches(root names)
    (if (rk/root-match root names)
        (rk/root-match root names)
        (if (eq (length (cdr names)) 0)
            'nil
            (rk/root-matches root (cdr names)))))
  
  ;;;;;;;;;;;;;;;;
  ;; find files ;;
  ;;;;;;;;;;;;;;;;
  (defun rk/find-project-files (root)
    "Finds all files in a given 'project'. What a project is, is determined by textmate.
  Contrary to 'textmate-find-project-files' this search uses find and it's prune option to
  not recurse into dirs that should be ignored. The shell command  outputed is sth like
  find -E . \\( -type f -a -not \\( -name \"*#\" -o -name \".gitignore\" -o -name \"*~\" -o -name \"*.lock\" -o -name \"*.DS_Store\" -o -name \"*elc\" \\) \\) -o -type d \\( -name \".git\" -o -name \".svn\" -o -name \"vendor\" -o -name \"fixtures\" -o -name \"tmp\" -o -name \"log\" -o -name \"classes\" -o -name \"build\" -o -name \"_temp\" \\) -not -prune | sed 's:/Users/robert/robertkrahn.org/notes//::'"
    (flet ((as-name-arg (string) (concat "-name \"" string "\""))
           ;; when rk/find-file-ignores = '("*#" ".gitignore") this
           ;; outputs "-name \"*#\" -o -name \".gitignore\""
           (make-ignore-args (ignore-list) (mapconcat 'as-name-arg ignore-list " -o ")))
      (split-string (shell-command-to-string
                     (concat "find -E " root " \\( -type f -a -not \\( "
                             (make-ignore-args rk/find-file-ignores)
                             " \\) \\) -o -type d \\( "
                             (make-ignore-args rk/find-dir-ignores)
                             " \\) -not -prune | sed 's:"
                             ,*rk/project-root*
                             "/::'")) "\n" t)))
  
  (setq
   rk/find-file-ignores '("*#" ".gitignore" "*~" "*.lock" "*.DS_Store" "*elc" "*.xcodeproj" "*.nib" "*.framework" "*.app" "*.pbproj" "*.pbxproj" "*.xcode" "*.xcodeproj" "*.bundle" "*.pyc" "*.elc")
   rk/find-dir-ignores '(".git" ".svn" "vendor" "fixtures" "tmp" "log" "classes" "build" "*_temp"))
  
  (defun rk/project-files (root)
    (sort
      (rk/find-project-files root)
      '(lambda (a b) (< (length a) (length b)))))
  
#+END_SRC
* grep
#+BEGIN_SRC emacs-lisp
;; writable grep
(require 'wgrep)
(setq wgrep-auto-save-buffer t)
#+END_SRC
* dired

#+BEGIN_SRC emacs-lisp
;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
;;; wdired
(eval-after-load "wdired"
  '(progn (define-key dired-mode-map (kbd "e") 'wdired-change-to-wdired-mode)
          (setq wdired-allow-to-change-permissions t)))
#+END_SRC

#+RESULTS:

** languages
*** lisp
**** general lispy stuff
#+BEGIN_SRC emacs-lisp
  (autoload 'enable-paredit-mode "paredit")
  
  (defun maybe-map-paredit-newline ()
    (unless (or (eq major-mode 'inferior-emacs-lisp-mode) (minibufferp))
      (local-set-key (kbd "RET") 'paredit-newline)))
  
  (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline)
  
  (eval-after-load 'paredit
    '(progn
       ;; These are handy everywhere, not just in lisp modes
       (global-set-key (kbd "M-(") 'paredit-wrap-round)
       (global-set-key (kbd "M-[") 'paredit-wrap-square)
       (global-set-key (kbd "M-{") 'paredit-wrap-curly)
  
       (global-set-key (kbd "M-)") 'paredit-close-round-and-newline)
       (global-set-key (kbd "M-]") 'paredit-close-square-and-newline)
       (global-set-key (kbd "M-}") 'paredit-close-curly-and-newline)
  
       (dolist (binding (list (kbd "C-<left>") (kbd "C-<right>")
                              (kbd "C-M-<left>") (kbd "C-M-<right>")))
         (define-key paredit-mode-map binding nil))
  
       ;; Disable kill-sentence, which is easily confused with the kill-sexp
       ;; binding, but doesn't preserve sexp structure
       (define-key paredit-mode-map [remap kill-sentence] nil)
       (define-key paredit-mode-map [remap backward-kill-sentence] nil)))
  
  
  ;; Compatibility with other modes
  
  (add-hook 'minibuffer-setup-hook 'conditionally-enable-paredit-mode)
  
  (defvar paredit-minibuffer-commands '(eval-expression
                                        pp-eval-expression
                                        eval-expression-with-eldoc)
    "Interactive commands for which paredit should be enabled in the minibuffer.")
  
  (defun conditionally-enable-paredit-mode ()
    "Enable paredit during lisp-related minibuffer commands."
    (if (memq this-command paredit-minibuffer-commands)
        (enable-paredit-mode)))
  
  (defun lisp-setup ()
    "Enable features useful in any Lisp mode."
    (enable-paredit-mode)
    (rainbow-delimiters-mode)
    (turn-on-eldoc-mode))
  
  (let* ((lispy-hooks '(emacs-lisp-mode-hook
                        ielm-mode-hook
                        lisp-mode-hook
                        inferior-lisp-mode-hook
                        pareditlisp-interaction-mode-hook
                        clojure-mode-hook)))
    (dolist (hook lispy-hooks)
      (add-hook hook 'lisp-setup)))
  
  
  ;; (define-key emacs-lisp-mode-map (kbd "C-x C-a") 'pp-macroexpand-last-sexp)
  
  ;; ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;; (defun rk/bounds-of-defun ()
  ;;   "uses beginning-of-defun and end-of-defun to determine the bounds"
  ;;   (save-excursion
  ;;     `(,(progn (beginning-of-defun) (point)) . ,(progn (end-of-defun) (point)))))
  
  ;; (defun rk/eval-defun-flash ()
  ;;   (interactive)
  ;;   (let* ((bounds (rk/bounds-of-defun))
  ;;          (start (car bounds))
  ;;          (end (cdr bounds)))
  ;;     (slime-flash-region start end 0.7)
  ;;     (eval-region start end t)))
  
  ;; (define-key emacs-lisp-mode-map (kbd "M-SPC") 'rk/eval-defun-flash)
#+END_SRC

**** clojure
#+BEGIN_SRC emacs-lisp
  ;;; nrepl setup
  (setq nrepl-hide-special-buffers t)
  (setq nrepl-popup-stacktraces-in-repl t)
  (setq nrepl-history-file "~/.emacs.d/nrepl-history")
  
  ;;; my nrepl keys
  
  (defvar rk/nrepl-key-map (make-keymap) "my nrepl keys")
  
  (defun rk/nrepl-print-and-mark (arg)
    (interactive "P")
    (push-mark (point) t t)
    (if arg
        (nrepl-pprint-eval-last-expression)
        (nrepl-eval-print-last-expression)))
  
  (define-key rk/nrepl-key-map (kbd "C-x C-p") 'rk/nrepl-print-and-mark)
  (define-key rk/nrepl-key-map (kbd "s-p") 'rk/nrepl-print-and-mark)
  (define-key rk/nrepl-key-map (kbd "s-d") 'nrepl-eval-last-expression)
  (define-key rk/nrepl-key-map (kbd "s-i") 'nrepl-inspect)
  (define-key rk/nrepl-key-map (kbd "s-I") 'nrepl-src)
  
  (define-minor-mode rk/nrepl-minor-mode
    "A minor mode so that my key settings override annoying major modes."
    nil " rknREPL" rk/nrepl-key-map)
  
  (defun rk/turn-on-nrepl-minor-mode () (rk/nrepl-minor-mode 1))
  
  (add-hook 'nrepl-interaction-mode-hook 'nrepl-turn-on-eldoc-mode)
  (add-hook 'nrepl-interaction-mode-hook 'rk/turn-on-nrepl-minor-mode t t)
  
  ;;; auto-complete
  (require 'ac-nrepl)
  (eval-after-load "auto-complete"
    '(add-to-list 'ac-modes 'nrepl-mode))
  (add-hook 'nrepl-mode-hook 'ac-nrepl-setup)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (add-to-list 'load-path (concat (expand-file-name "~/.emacs.d/site-lisp/") "nrepl-inspect"))
  (require 'nrepl-inspect)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (require 'nrepl-ritz)
  (define-key nrepl-interaction-mode-map (kbd "C-x C-j") 'nrepl-javadoc)
  (define-key nrepl-mode-map (kbd "C-x C-j") 'nrepl-javadoc)
  (define-key nrepl-interaction-mode-map (kbd "C-x C-h") 'nrepl-ritz-apropos)
  (define-key nrepl-mode-map (kbd "C-x C-h") 'nrepl-ritz-apropos)
#+END_SRC
* version control
** magit
#+BEGIN_SRC emacs-lisp
  (setq magit-save-some-buffers nil
        magit-process-popup-time 10
        magit-completing-read-function 'magit-ido-completing-read
        magit-log-auto-more t
        magit-log-cutoff-length 300)
  
  (defun magit-status-somedir ()
    (interactive)
    (let ((current-prefix-arg t))
      (magit-status default-directory)))
  
  (define-key vc-prefix-map (kbd "SPC") 'magit-status-somedir)
#+END_SRC
* helm
** basics
#+BEGIN_SRC emacs-lisp
  (require 'helm-config)
  (require 'helm-imenu)
  (helm-mode 1)
  
  (setq helm-candidate-number-limit nil
        helm-samewindow nil ;; already covered by my window init
        helm-c-use-adaptative-sorting t
        enable-recursive-minibuffers t)
  
  (defun rk/helm-symbols (arg)
    (interactive "P")
    ;; see `helm-occur'
    (let ((init (and (equal arg '(4)) (thing-at-point 'symbol)))
          (buffers (list (current-buffer)))
          (helm-multi-occur-buffer-list (list (buffer-name (current-buffer))))
          ;; (helm-compile-source-functions
          ;;  ;; rule out helm-match-plugin because the input is one regexp
          ;;  (delq 'helm-compile-source--match-plugin
          ;;        (copy-sequence helm-compile-source-functions)))
          )
      (helm-occur-init-source)
      (helm-attrset 'name "Occur" helm-c-source-occur)
      (helm :prompt "Search for symbol: "
            :input init
            :default (thing-at-point 'symbol)
            :sources '(helm-c-source-imenu
                       helm-c-source-occur)
            :buffer "*helm symbols*")))
  
  (defvar rk/helm-c-source-projectf
    '((name . "Project files")
      (disable-shortcuts) ;; Needed for filenames with capitals letters.
      (candidates . (lambda () (with-helm-current-buffer
                            (let ((dir (rk/project-root)))
                              (mapcar (lambda (ea) (concat dir ea)) (rk/project-files dir))))))
      (type . file))
    "Uses `rk/project-files' as input.")
  
  (defun rk/helm-projectf ()
    (interactive)
    (helm :sources 'rk/helm-c-source-projectf
          :buffer "*helm project files*"))
  
  (defun rk/helm-buffers-and-files ()
    (interactive)
    (helm
     :prompt "Switch to: "
     :candidate-number-limit 20
     :sources '(helm-c-source-buffers-list
                rk/helm-c-source-projectf
                helm-c-source-recentf
                helm-c-source-bookmarks)))
  
#+END_SRC
** auto-complete
#+BEGIN_SRC emacs-lisp
  (defvar rk/helm-c-source-ac-completion
    '((name . "Auto Completion")
      (init . (lambda ()
                (with-helm-current-buffer
                  (ac-abort)
                  (ac-start)
                  (helm-attrset 'ac-candidates (ac-candidates))
                  (ac-abort))))
      (candidates . (lambda () (helm-attr 'ac-candidates)))
      (action . (lambda (partial) (insert-and-inherit partial
                              ;; fixme not only usable for js...
                              ;; (substring partial (length (rk/ac-slime-js-prefix-string)))
                                   
                              )))
      ))
  
  (defun rk/helm-ac-completion ()
    (interactive)
    (helm
     :prompt "Completion: "
     :sources '(rk/helm-c-source-ac-completion)))
#+END_SRC
* auto-complete
#+BEGIN_SRC emacs-lisp
  ;; -*-no-byte-compile: t; -*-
  
  (require 'auto-complete)
  (require 'auto-complete-config)
  (global-auto-complete-mode t)
  (setq ac-auto-start nil)
  (setq ac-dwim nil) ; To get pop-ups with docs even if a word is uniquely completed
  (setq ac-quick-help-delay 0.3)
  (setq ac-use-fuzzy t)
  (define-key ac-completing-map (kbd "C-n") 'ac-next)
  (define-key ac-completing-map (kbd "C-p") 'ac-previous)
  
  ;;----------------------------------------------------------------------------
  ;; Use Emacs' built-in TAB completion hooks to trigger AC (Emacs >= 23.2)
  ;;----------------------------------------------------------------------------
  (setq tab-always-indent t)  ;; use 'complete when auto-complete is disabled
  (add-to-list 'completion-styles 'initials t)
  
  ;; hook AC into completion-at-point
  (defun set-auto-complete-as-completion-at-point-function ()
    (setq completion-at-point-functions '(auto-complete)))
  (add-hook 'auto-complete-mode-hook 'set-auto-complete-as-completion-at-point-function)
  
  
  (set-default 'ac-sources
               '(ac-source-dictionary
                 ac-source-words-in-buffer
                 ac-source-words-in-same-mode-buffers
                 ac-source-words-in-all-buffer))
  
  (dolist (mode '(magit-log-edit-mode log-edit-mode org-mode text-mode haml-mode
                  sass-mode yaml-mode csv-mode espresso-mode haskell-mode
                  html-mode sh-mode clojure-mode
                  lisp-mode textile-mode markdown-mode tuareg-mode
                  js3-mode css-mode less-css-mode
                  octave-mode))
    (add-to-list 'ac-modes mode))
  
  
  ;; Exclude very large buffers from dabbrev
  (defun sanityinc/dabbrev-friend-buffer (other-buffer)
    (< (buffer-size other-buffer) (* 1 1024 1024)))
  
  (setq dabbrev-friend-buffer-function 'sanityinc/dabbrev-friend-buffer)
  
#+END_SRC
* social
** erc
#+BEGIN_SRC elisp
  (require 'erc)
  
  (setq erc-hide-list '("JOIN" "PART" "QUIT")
        erc-nick "rksm"
        erc-notifications-mode t
        erc-input-line-position -3)
  
  (erc-autojoin-mode t)
  (setq erc-autojoin-channels-alist
    '((".*\\.freenode.net" "#emacs" "#Node.js" "#clojure" "#ace")))
  
  (defun rk/erc-make-frame ()
    (interactive)
    (make-frame)
    (rk/erc-setup-windows))
  
  (defun rk/erc-setup-windows ()
    (interactive)
    (let ((erc-buffers (butlast (erc-buffer-list) 1)))
      ;; create new windows for erc
      (dotimes (i (- (length erc-buffers) 1))
        (split-window-vertically))
      ;; assign erc buffers to new windows
      (loop for win being the windows for buf in erc-buffers do (set-window-buffer win buf))
      (balance-windows)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; znc
  ;;; /server robert.krahn.org 6666 rksm:<pass>
  (add-to-list 'load-path (concat (expand-file-name "~/.emacs.d/site-lisp/") "znc"))
  (require 'znc)
  (setq znc-servers
        '(("robertkrahn.org" 6666 nil ((network-slug "rksm" "tebor1")))))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; growl
  
  (defvar growlnotify-command (executable-find "growlnotify") "The path to growlnotify")
  
  (when growlnotify-command
  
    (defun growl (title message)
      "Shows a message through the growl notification system using
   `growlnotify-command` as the program."
      (flet ((encfn (s) (encode-coding-string s (keyboard-coding-system))) )
        (let* ((process (start-process "growlnotify" nil
                                       growlnotify-command
                                       (encfn title)
                                       "-a" "Emacs"
                                       "-n" "Emacs")))
          (process-send-string process (encfn message))
          (process-send-string process "\n")
          (process-send-eof process)))
      t)
  
    (defun rk/erc-nick-mentioned-hook (match-type nick message)
      "Shows a growl notification, when user's nick was mentioned. If the buffer is currently not visible, makes it sticky."
      (unless (posix-string-match "^\\** *Users on #" message)
        (growl
         (concat "ERC: name mentioned on: " (buffer-name (current-buffer)))
         message)))
  
    (add-hook 'erc-text-matched-hook 'rk/erc-nick-mentioned-hook))
#+END_SRC
* javascript
** js3
#+BEGIN_SRC elisp
  
  (defvar js-modes '(js-mode js2-mode js3-mode))
  
  (defmacro add-mode-hook-for-js (hook-function &optional append)
    `(dolist (hook '(js-mode-hook js2-mode-hook js3-mode-hook))
       (add-hook hook ,hook-function ,append)))
  
  (defcustom preferred-javascript-mode 'js3-mode
    "Javascript mode to use for .js files"
    :type 'symbol
    :group 'programming
    :options js-modes)
  
  (defvar preferred-mmm-javascript-mode 'js-mode)
  (defvar preferred-javascript-indent-level 4)
  
  ;; js2-mode
  (setq js2-use-font-lock-faces t
        js2-mode-must-byte-compile nil
        js2-basic-offset preferred-javascript-indent-level
        js2-indent-on-enter-key t
        js2-auto-indent-p t
        js2-bounce-indent-p t)
  
  ;; js-mode
  (setq js-flat-functions t)
  (setq js-indent-level preferred-javascript-indent-level)
  
  ;; (eval-after-load "js"
  ;;   '(progn
  ;;      (modify-syntax-entry ?- "_" js-mode-syntax-table)))
  
  ;; standard javascript-mode
  (setq javascript-indent-level preferred-javascript-indent-level)
  
  
  ;; MMM submode regions in html
  (eval-after-load 'mmm-vars
    `(progn
       (mmm-add-group
        'html-js
        '((js-script-cdata
           :submode ,preferred-mmm-javascript-mode
           :face mmm-code-submode-face
           :front "<script[^>]*>[ \t\n]*\\(//\\)?<!\\[CDATA\\[[ \t]*\n?"
           :back "[ \t]*\\(//\\)?]]>[ \t\n]*</script>"
           :insert ((?j js-tag nil @ "<script language=\"JavaScript\">"
                        @ "\n" _ "\n" @ "</script>" @)))
          (js-script
           :submode ,preferred-mmm-javascript-mode
           :face mmm-code-submode-face
           :front "<script[^>]*>[ \t]*\n?"
           :back "[ \t]*</script>"
           :insert ((?j js-tag nil @ "<script language=\"JavaScript\">"
                        @ "\n" _ "\n" @ "</script>" @)))
          (js-inline
           :submode ,preferred-mmm-javascript-mode
           :face mmm-code-submode-face
           :front "on\w+=\""
           :back "\"")))
       (dolist (mode (list 'html-mode))
         (mmm-add-mode-ext-class mode "\\.r?html\\(\\.erb\\)?$" 'html-js))))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; no annoying warnings (help-echos) that won't go away for js3
  (add-hook 'js3-mode-hook (lambda () (tooltip-mode -1)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;; use jshint
  ;; On-the-fly syntax checking
  ;; (require 'flymake-jshint)
  ;; (setq flymake-jslint-command "jshint")
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; js3 specific
  (eval-after-load "js3"
    '(progn
      (defadvice js3-end-of-line (before js3-eol-support-mark)
       "allow to set mark int transient mark mode"
       (rk/set-mark-on-shift-press))
  
      (defadvice js3-beginning-of-line (before js3-bol-support-mark)
       "allow to set mark int transient mark mode"
       (rk/set-mark-on-shift-press))
  
      ;; (defadvice js3-mode-create-imenu-index (after js3-lively-imneu-defs)
      ;;   "Add Lively class/method/object defs into return value for `imenu--index-alist'."
      ;;   ;; store into this value to change return
      ;;   ad-return-value)
  
      (ad-activate 'js3-end-of-line)
      (ad-activate 'js3-beginning-of-line)
      ;; (ad-activate 'js3-mode-create-imenu-index)
  
      (modify-syntax-entry ?_ "w" js3-mode-syntax-table)))
  
  ;; (set-default 'js3-indent-level 4)
  
  (setq js3-indent-level 4
        js3-cleanup-whitespace t
        js3-consistent-level-indent-inner-bracket t
        js3-enter-indents-newline t
        js3-highlight-level 3
        js3-mirror-mode nil
        js3-missing-semi-one-line-override t
        js3-rebind-eol-bol-keys t
        js3-highlight-external-variables t)
  
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; pretty print json
  (defun rk/pretty-json ()
    (interactive)
    (when (not (region-active-p))
      (error "need selection"))
    (let ((start (min (point) (mark)))
          (end (max (point) (mark))))
      (save-excursion
        (save-restriction
          (narrow-to-region start end)
          (goto-char (point-min))
          ;; line break after first "{"
          (if (re-search-forward "{\\([^\n]\\)" (point-max) t)
              (replace-match "{\n\\1" nil nil))
          ;; line break after every,
          (while (re-search-forward ",[\s-]*\\([^\n]\\)" (point-max) t)
            (replace-match ",\n\\1" nil nil))
          (goto-char (point-max))
          (if (re-search-backward "\\([^\n]\\)}" (point-min) t)
              (replace-match "\\1\n}" nil nil))
          (delete-trailing-whitespace (point-min) (point-max)))
        (indent-region start end))))
  
  (defun rk/remove-line-breaks ()
    (interactive)
    (when (not (region-active-p))
      (error "need selection"))
    (save-excursion
      (save-restriction
        (narrow-to-region (point) (mark))
        (goto-char (point-min))
        (while (re-search-forward "\n[\s-]*" (point-max) t)
          (replace-match "" nil nil)))))
  
  
  (defun rk/convert-js-var-block (start end)
    (interactive "r")
    (let ((new-end start))
      (save-excursion
        (save-restriction
          (narrow-to-region start end)
          (goto-char (point-min))
          ;; skip the first var
          (re-search-forward "\\s-*\\(var\\)\\s-+" (point-max) t)
          ;; replace all preceding vars
          (while (re-search-forward "\\(;\\)?\\(\\s-*\n\\s-*var\\s-+\\)" (point-max) t)
            (replace-match ",\n" nil nil))
          (setq new-end (point-max)))
        (indent-region start new-end))))
  
  (defun rk/toggle-js-whitespace-cleanup ()
    (interactive)
    (set-default 'js3-cleanup-whitespace (not js3-cleanup-whitespace))
    (message (concat "js3-cleanup-whitespace set to " (prin1-to-string js3-cleanup-whitespace))))
  
  (defun rk/js-make-pretty-with-uglify (js-source)
    (let ((temp-file (make-temp-file "ugly-json")))
      (unwind-protect
          (with-temp-buffer
            (insert js-source)
            (write-file temp-file)
            (let* ((cmd (concat "uglifyjs --beautify --indent 4 " temp-file))
                   (result (shell-command-to-string cmd)))
              (if (string-match "DEBUG: Error" result)
                  (message "Error running JS beautifier. Is source code valid?")
                (substring result 1 (- (length result) 2)))))
        (delete-file temp-file))))
  
  (defun rk/js-prettify-and-insert ()
    (interactive)
    ;; escape source in "(...);" so that JSON expressions go through
    (rk/with-active-region-or-line start end
      (let ((js-source (format "(%s);" (rk/current-region-or-line-string)))
            deactivate-mark)
        (kill-region start end)
        (push-mark nil t t)
        (insert (rk/js-make-pretty-with-uglify js-source)))))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; js3 ast helper
  (defun rk/js3-node-name-at-point ()
    ""
    (interactive)
    (message (js3-node-short-name (js3-node-at-point))))
  
  (defun rk/js3-get-func-def-info ()
    "example: returns '(\"$world\" \"addScript\" \"foo\"
    \"$world.addScript(fu|nction foo() {});\") from
    '$world.addScript(fu|nction () {});'"
    (let* ((current-node (js3-node-at-point))
           (func-node (if (= js3-FUNCTION (js3-node-type current-node))
                          current-node
                        (js3-node-get-enclosing-scope current-node)))
           (func-parent-node (js3-node-parent func-node))
            target-node)
       (when (and func-node func-parent-node (= js3-CALL (js3-node-type func-parent-node)))
         (setq target-node (js3-call-node-target func-parent-node))
         (mapcar 'js3-node-string (list
                                   (js3-prop-get-node-left target-node)
                                   (js3-prop-get-node-right target-node)
                                   (js3-function-node-name func-node)
                                   func-parent-node)))))
  
  ;; js3-node-abs-end
  (defun rk/js3-backward-up ()
    ""
    (interactive "")
    (let ((old-pos (point))
          (new-pos (js3-node-abs-pos (js3-node-parent (js3-node-at-point)))))
      (when (= old-pos new-pos)
          (setq new-pos (js3-node-abs-pos (js3-node-get-enclosing-scope (js3-node-at-point)))))
      ;; (if this-command-keys-shift-translated (message "fooo"))
      (goto-char new-pos)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;; (require 'jquery-doc)
  
  ;; adds ac-source-jquery to the ac-sources list
  ;; (remove-hook 'js3-mode-hook 'jquery-doc-setup)
  ;; (add-hook 'js3-mode-hook 'jquery-doc-setup)
  
  ;;; (remove-hook 'js3-mode-hook 'jquery-doc-setup)
  
  ;; (eval-after-load "jquery-doc"
  ;;  '(progn
  ;;     (dolist (hook '(j3s-mode-hook js2-mode-hook js-mode-hook)) (add-hook hook 'jquery-doc-setup))))
  
#+END_SRC
* my own helpers
** buffers
#+BEGIN_SRC emacs-lisp
;;; http://stackoverflow.com/questions/3669511/the-function-to-show-current-files-full-path-in-mini-buffer
(defun rk/copy-full-path-to-kill-ring ()
  "copy buffer's full path to kill ring"
  (interactive)
  (when buffer-file-name
    (let ((file-name (file-truename buffer-file-name)))
      (message file-name)
      (kill-new file-name))))

(defun rk/copy-buffer-name-to-kill-ring ()
  "copy buffer's full path to kill ring"
  (interactive)
  (when buffer-file-name
    (let ((name (file-name-nondirectory buffer-file-name)))
      (message name)
      (kill-new name))))
#+END_SRC


** editing commands
*** lines
#+BEGIN_SRC emacs-lisp
  (defun rk/clear-buffer ()
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)))
  
  (defun rk/open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))
  
  (defun rk/open-line-above ()
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))
#+END_SRC

** comments
#+BEGIN_SRC emacs-lisp
  (defun rk/divider (&optional length suppress-newline)
    (interactive "p")
    (message (prin1-to-string length))
    (when (or (not length) (= length 1)) (setq length 58))
    (when (< length 6) (setq length 6))
    (beginning-of-line)
    (let ((div-start-pos (point)))
      ;; (set-mark div-start-pos)
      (delete-horizontal-space)
      (insert "-")
      (comment-or-uncomment-region-or-line)
      (indent-according-to-mode)
      (end-of-line)
      (setq length (- length (- (point) div-start-pos)))
      (insert (apply 'concat (make-list (/ length 2) "=-")))
      (if suppress-newline
          (forward-line)
        (insert "\n"))))
  
  (defun rk/comment-box (reg-start reg-end)
    "my own comment box, using the divider"
    (interactive "r")
    (let ((start (if (region-active-p) reg-start (line-beginning-position)))
          (end (if (region-active-p) reg-end (line-end-position))))
      (comment-or-uncomment-region-or-line)
      (indent-according-to-mode)
      (setq end (line-end-position))
      (setq max-line-length 0)
      (unless (region-active-p)
        (set-mark start) (goto-char end))
      (rk/do-for-each-line-in-region (lambda (line)
                                       (setq max-line-length
                                             (max max-line-length (length line)))
                                       line) t)
      (setq max-line-length (+ max-line-length (length (rk/current-line-indent))))
      (deactivate-mark)
      (goto-char end)
      (newline)
      (rk/divider (1+ max-line-length) t)
      (goto-char start)
      (forward-line -1)
      (end-of-line)
      (newline)
      (rk/divider (1+ max-line-length) t)))
#+END_SRC
* key setup
** window related
#+BEGIN_SRC emacs-lisp
  (when *is-a-mac*
   (dolist (map `(,global-map ,minibuffer-local-map))
     (progn
       (print (prin1-to-string map))
       (define-key map (kbd "<s-home>") 'windmove-left)
       (define-key map (kbd "<s-end>") 'windmove-right)
       (define-key map (kbd "<s-prior>") 'windmove-up)
       (define-key map (kbd "<s-next>") 'windmove-down))))
#+END_SRC

** for helm
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'rk/helm-buffers-and-files)
  
  (define-key helm-command-map (kbd "i") 'rk/helm-symbols)
  (define-key helm-command-map (kbd "b") 'rk/helm-buffers-and-files)
  (define-key helm-command-map (kbd "g") 'helm-do-grep)
#+END_SRC
** misc
#+BEGIN_SRC emacs-lisp
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; keys
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;; Activate occur easily inside isearch
  (define-key isearch-mode-map (kbd "C-o")
    (lambda () (interactive)
      (let ((case-fold-search isearch-case-fold-search))
        (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; umlauts
  (global-unset-key (kbd "M-u"))
  (global-set-key (kbd "M-u a") (lambda () (interactive) (insert ?\ä)))
  (global-set-key (kbd "M-u o") (lambda () (interactive) (insert ?\õ)))
  (global-set-key (kbd "M-u u") (lambda () (interactive) (insert ?\ü)))
  (global-set-key (kbd "M-u A") (lambda () (interactive) (insert ?\Ä)))
  (global-set-key (kbd "M-u O") (lambda () (interactive) (insert ?\Ö)))
  (global-set-key (kbd "M-u U") (lambda () (interactive) (insert ?\Ü)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (require 'subword)
  (global-set-key [C-s-268632066] 'subword-backward) ; C-s-f
  (global-set-key [C-s-268632070] 'subword-forward) ; C-s-b
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  (defun rk/move-beginning-of-line (arg)
    "move either at `bol' or when already there then in front of
  the first non-whitespace char"
    (interactive "p")
    (let ((was-at-bol (bolp)))
      (move-beginning-of-line arg)
      (when was-at-bol
        (skip-chars-forward "\* \t"))))
  
  (global-set-key (kbd "C-a") 'rk/move-beginning-of-line)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; moving text, really important
  (global-set-key [C-s-268632080] 'move-text-up) ; C-s-p
  (global-set-key [C-s-268632078] 'move-text-down) ; C-s-n
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; select line
  (defun rk/mark-line ()
    "activates the mark for the whole line. If line is already
  marked, shrinks the selection to the first non-whitespace char
  and end of the lines. Further command execution toggle between
  the states"
    (interactive)
    (let* ((start (if (region-active-p) (region-beginning) (point-at-bol)))
          (end (if (region-active-p) (region-end) (point-at-eol)))
          (line-marked-p (and (region-active-p) (= start (point-at-bol)) (= end (point-at-eol)))))
      (setq start (if line-marked-p
                      (save-excursion
                        ;; point in front of the first non-whitespace char
                        (beginning-of-line) (skip-chars-forward "\* \t")
                        (point))
                    ;; push the current pos first so we can easily jump back
                    (push-mark nil t) (point-at-bol)))
      (push-mark start t t)
      (goto-char end)))
  
  (global-set-key (kbd "s-l") 'rk/mark-line)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (global-set-key (kbd "C-c j") 'join-line)
  (global-set-key (kbd "C-c J") (lambda () (interactive) (join-line 1)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; duplicate line
  (defun duplicate-line (arg)
    "Duplicates the current line and inserts it above. If called
  with prefix `arg' inserts lien below"
    (interactive "P")
    (message (prin1-to-string arg))
    (save-excursion
      (let ((line-text (buffer-substring-no-properties
                        (line-beginning-position)
                        (line-end-position))))
        (if arg (move-end-of-line 1) (move-beginning-of-line 1))
        (newline)
        (unless arg (previous-line))
        (insert line-text))))
  
  (global-set-key (kbd "C-c p") 'duplicate-line)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; remove until line start
  (defun rk/delete-backward-line (region-start region-end)
    "If there is an active region, delete it. Otherwise remove everything
  from the beginning of the line to the current point.
  If point is at line start, remove line break."
    (interactive "r")
    (if (region-active-p)
        (delete-region region-start region-end)
      (let ((pos (point))
          (line-start-pos (save-excursion (forward-line 0) (point))))
      (delete-region
       (if (equal pos line-start-pos) (- pos 1) line-start-pos)
       (point)))))
  
  (global-set-key [s-backspace] 'rk/delete-backward-line)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  (global-set-key (kbd "s-w") 'kill-this-buffer)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (global-set-key [C-backspace] 'kill-word)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; escape as quit
  (defun rk/escape-key-action ()
    (interactive)
    (if (region-active-p)
        (progn
          (exchange-point-and-mark)
          (keyboard-quit))
      (keyboard-quit)))
  
  (global-set-key [escape] 'rk/escape-key-action)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  
  ;;; for quickcursor edits
  (global-set-key [C-f11] 'server-edit)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (fset 'open-eshell-minimized
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([24 50 s-next f6 115 115 115 115 115 115 115 115 115 115 115 115 115 113] 0 "%d")) arg)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (require 'iy-go-to-char)
  (global-set-key (kbd "s-.") 'iy-go-to-char)
  (global-set-key (kbd "C-c .") 'iy-go-to-char)
  (global-set-key (kbd "s-,") 'iy-go-to-char-backward)
  (global-set-key (kbd "C-c ,") 'iy-go-to-char-backward)
  (setq iy-go-to-char-key-forward nil
        iy-go-to-char-key-backward nil)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; ace
  (require 'ace-jump-mode)
  (global-set-key (kbd "s-j") 'ace-jump-mode)
  (global-set-key (kbd "s-J") 'ace-jump-mode-pop-mark)
  (set-default 'ace-jump-mode-submode-list '(ace-jump-char-mode
                                             ace-jump-word-mode
                                             ace-jump-line-mode))
  
  (require 'cl)
  (setq ace-jump-mode-scope 'window
        ace-jump-mode-move-keys (loop for i from ?a to ?z collect i)
        ace-jump-mode-case-fold nil)
  
  (ace-jump-mode-enable-mark-sync)
  (define-key global-map (kbd "C-x SPC") 'ace-jump-mode-pop-mark)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; artist mode
  (eval-after-load "artist"
    '(progn
      (define-key artist-mode-map (kbd "s-o") 'artist-select-operation)))
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (global-set-key (kbd "M-/") 'hippie-expand)
  (global-set-key (kbd "s-?") 'auto-complete)
  
  (set-default 'yas/trigger-key "s-\\")
  ;; (yas/initialize)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  (defun rk/shell-mode-add-keys ()
    (local-set-key (kbd "s-p") (lambda () (interactive) (rk/shell-exec-expression 4)))
    (local-set-key (kbd "s-d") 'rk/shell-exec-expression))
  
  (add-hook 'sh-mode-hook 'rk/shell-mode-add-keys)
  
  ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  
  ;;; init multiple cursors
  (require 'multiple-cursors)
  
  ;(define-key cua-global-keymap [(control return)] 'set-rectangular-region-anchor)
  (global-set-key [(control return)] 'set-rectangular-region-anchor)
  
  (global-set-key [C-s-268632067] 'mc/edit-lines)  ; C-s-c
  (global-set-key [C-s-268632069] 'mc/edit-ends-of-lines)  ; C-s-e
  (global-set-key [C-s-268632065] 'mc/edit-beginnings-of-lines)  ; C-s-a
  
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
  (global-set-key (kbd "C-M-n") 'mc/mark-next-lines)
  (global-set-key (kbd "C-M-p") 'mc/mark-previous-lines)
  (global-set-key (kbd "<M-return>") 'mc/mark-more-like-this-extended) ; like the other two, but takes an argument (negative is previous)
  
  (define-key mc/keymap (kbd "<escape>") 'multiple-cursors-mode)
  (define-key mc/keymap (kbd "<return>") nil) ; <return> should work with mc
  
  (defun rk/eval-and-replace-last-sexp (value)
    "Evaluate the sexp at point and replace it with its value"
    (interactive (list (eval-last-sexp nil)))
    (kill-sexp -1)
    (insert (format "%S" value)))
  
  (global-set-key (kbd "C-x C-r") 'rk/eval-and-replace-last-sexp)
  
  (global-set-key (kbd "C-x C-p") 'eval-print-last-sexp)
  
  (global-set-key (kbd "C-x p") 'mark-page)
  
  ;;; expand-region
  (require 'expand-region)
  (global-set-key (kbd "S-s-SPC") 'er/expand-region)
  (global-set-key [C-s-268632064] 'er/contract-region) ; C-s-SPC
#+END_SRC
** CMD keys
#+BEGIN_SRC emacs-lisp
  (eval-after-load "helm-config"
    '(progn
       (global-set-key (kbd "s-a") 'rk/helm-buffers-and-files)
       (global-set-key (kbd "M-x") 'helm-M-x)
       (global-set-key (kbd "s-k") 'rk/clear-buffer)
       (global-set-key (kbd "s-E") 'rk/helm-ac-completion)
       (global-set-key (kbd "s-S") 'helm-google-suggest)
       (global-set-key (kbd "s-R") 'helm-resume)
       (global-set-key (kbd "s-T") 'helm-find)
       (global-set-key (kbd "s-t") 'rk/helm-symbols)
       (global-set-key (kbd "s-g") (lambda (arg) (interactive "P") (rk/helm-symbols '(4))))
       (global-set-key (kbd "s-G") 'rk/helm-symbols)
       (global-set-key (kbd "s-/") 'comment-or-uncomment-region-or-line)
  
       ;; currently helm-yasnippet seems to be broken... :(
       ;; (require 'helm-c-yasnippet)
       ;; (global-set-key (kbd "s-C") 'helm-c-yas-complete)
       ;; (require 'yasnippet)
       ;; (global-set-key (kbd "s-C") 'yas/insert-snippet)
       ))
#+END_SRC
** CMD-Shift-L map
#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "s-L"))
  (if (boundp '*textmate-mode-map*)
      (define-key *textmate-mode-map* (kbd "s-L") nil))
  
  (defvar l-map (make-keymap)
    "Keymap for local bindings and functions, prefixed by (s-L)")
  (define-key global-map (kbd "s-L") 'L-prefix)
  (fset 'L-prefix l-map)
  
  (defmacro add-to-l-map (&rest mappings)
    `(loop for (keys func)
           on ',mappings
           by 'cddr
           do (define-key l-map keys func)))
  
  (add-to-l-map
   "bb"   helm-buffers+
   "bc"   clone-buffer
   "bdel" delete-this-file
   "bdiff" diff-buffer-with-file
   "bi"   clone-indirect-buffer
   "br"   rename-this-file-and-buffer
   "caa"  align
   "car"  align-regexp
   "clear" rk/clear-buffer
   "date" rk/insert-date
   "dup"  duplicate-line
   "dp"   rk/copy-full-path-to-kill-ring
   "dP"   rk/copy-buffer-name-to-kill-ring
   "ds"   dictionary-search
   "dm"   dictionary-popup-matching-words
   "eb"   ediff-buffers
   "ed"   ediff-directories
   "el"   ediff-regions-linewise
   "ew"   ediff-regions-wordwise
   "ef"   ediff-files
   "ep"   ediff-patch-buffer
   "em"   ediff-merge-buffers
   "ercf" rk/erc-make-frame
   "ercw" rk/erc-setup-windows
   "fn"   find-name-dired
   "fs"   rk/fringe-shrink
   "fw"   rk/fringe-widen
   "g"    helm-do-grep
   "G"    rgrep
   "h$"   rk/jQuery-doc
   "ha"   helm-c-apropos
   "hb"   helm-browse-code
   "hc"   describe-key-briefly
   "hd"   apropos-documentation
   "hf"   describe-function
   "hh"   help-for-help
   "hi"   helm-info-emacs
   "hk"   helm-show-kill-ring
   "hl"   helm-locate
   "hL"   view-lossage
   "hm"   helm-man-woman
   "hp"   finder-by-keyword
   "hq"   help-quit
   "hr"   helm-register
   "hs"   describe-syntax
   "hu"   helm-ucs
   "hv"   describe-variable
   "hw"   where-is
   "hy"   helm-show-kill-ring
   "h%"   helm-regexp
   "ii"   rk/images-find-image-strings-and-replace-with-image
   "ir"   rk/images-replace-inserted-images-with-image-strings
   "iy"   rk/images-paste-and-insert-from-clipboard
   "is"   rk/images-read-rescale-factor
   "jsc"  rk/slime-js-set-doit-context
   "json" rk/pretty-json
   "jsp"  rk/js-prettify-and-insert
   "jsl"  rk/slime-js-overlay-make-or-update
   "jsL"  rk/slime-js-overlay-remove-overlay-at-point
   "jsv"  rk/convert-js-var-block
   "jssr" slime-js-sticky-select-remote
   "jssw" rk/toggle-js-whitespace-cleanup
   "jsstart" rk/slime-js-start
   "lf"   flush-lines
   "lF"   keep-lines
   "lg"   goto-line
   "lke"  rk/lively-eval-add-method-to-class
   "lkfo" rk/find-same-file-in-ww-or-core-other-window
   "lkm"  rk/ww-mirror-commit-from-merge-spec
   "lks"  rk/mirror-lively-to-my-server
   "lnb"  rk/remove-line-breaks
   "lt"   toggle-truncate-lines
   "lu"   lively-update
   "lv"   lively
   "lV"   lively-stop
   "L"    goto-line
   "ma"   artist-mode
   "mdiff" diff-mode
   "mmd"  markdown-mode
   "mfm"  flymake-mode
   "msw"  subword-mode
   "mfw"  follow-mode
   "mfs"  flyspell-mode
   "morg" org-mode
   "mw"   whitespace-mode
   "name" rk/insert-name-email
   "occ"  occur
   "op"   org-insert-property-drawer
   "ot"   org-show-todo-tree
   "or"   remember
   "q"    query-replace
   "Q"    query-replace-regexp
   "rw"   resize-window
   "so"   open-eshell-minimized
   "ss"   eshell
   "sx"   rk/shell-exec-expression
   "sudo" sudo-edit
   "t1"   rk/transpose-region-remember-region-1
   "t2"   rk/transpose-region-active-with-region-1
   "term" rk/visit-term-buffer
   "ui"   ucs-insert
   "U"    browse-url-at-point
   "v="   vc-diff
   "va"   vc-annotate
   "vd"   vc-dir
   "vD"   vc-delete-file
   "vF"   vc-pull
   "vgl"  gist-list
   "vgf"  gist-fetch
   "vgp"  gist-region-or-buffer
   "vl"   vc-print-log
   "vu"   vc-revert
   "vv"   vc-next-action
   "vm"   magit-status-somedir
   "work" tomatinho
   "ws"   rk/copy-stringified
   "wm"   whitespace-mode
   "wt"   delete-trailing-whitespace
   "xx"   execute-extended-command
   "xb"   eval-buffer
   "xe"   eval-last-sexp
   "xp"   eval-print-last-sexp
   "xr"   eval-region
   "xs"   slime-eval-buffer
   "ye"   yas/exit-all-snippets
   "yc"   helm-c-yas-complete
   "!"    shell-command
   "^"    join-line
   "//"   comment-or-uncomment-region-or-line
   "/b"   rk/comment-box
   "/d"   rk/divider)
#+END_SRC
* theming / colors
** theme
#+BEGIN_SRC emacs-lisp
(load-theme 'tango-dark)
 #+END_SRC)
** font size
#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun font-name-replace-size (font-name new-size)
  (let ((parts (split-string font-name "-")))
    (setcar (nthcdr 7 parts) (format "%d" new-size))
    (mapconcat 'identity parts "-")))

(defun increment-default-font-height (delta)
  "Adjust the default font height by DELTA on every frame.
The pixel size of the frame is kept (approximately) the same.
DELTA should be a multiple of 10, in the units used by the
:height face attribute."
  (let* ((new-height (+ (face-attribute 'default :height) delta))
         (new-point-height (/ new-height 10)))
    (dolist (f (frame-list))
      (with-selected-frame f
        ;; Latest 'set-frame-font supports a "frames" arg, but
        ;; we cater to Emacs 23 by looping instead.
        (set-frame-font (font-name-replace-size (face-font 'default)
                                                new-point-height)
                        t)))
    (set-face-attribute 'default nil :height new-height)
    (message "default font size is now %d" new-point-height)))

(defun increase-default-font-height ()
  (interactive)
  (increment-default-font-height 10))

(defun decrease-default-font-height ()
  (interactive)
  (increment-default-font-height -10))

(global-set-key (kbd "C-M-=") 'increase-default-font-height)
(global-set-key (kbd "C-M--") 'decrease-default-font-height)
#+END_SRC

* custom
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat dotfiles-dir "custom.el"))
  (load custom-file)
#+END_SRC
